var Skope=function(){"use strict";function parseHexToInt(e){return!e.match(/[^a-f0-9]/i)?parseInt(e,16):NaN}function validateAndParseHex(e,t,n){const r=parseHexToInt(e);if(Number.isNaN(r)||void 0!==n&&n!==e.length)throw new SyntaxError(t+": "+e);return r}function parseHexadecimalCode(e){const t=validateAndParseHex(e,"Malformed Hexadecimal",2);return String.fromCharCode(t)}function parseUnicodeCode(e,t){const n=validateAndParseHex(e,"Malformed Unicode",4);if(void 0!==t){const e=validateAndParseHex(t,"Malformed Unicode",4);return String.fromCharCode(n,e)}return String.fromCharCode(n)}function isCurlyBraced(e){return"{"===e.charAt(0)&&"}"===e.charAt(e.length-1)}function parseUnicodeCodePointCode(e){if(!isCurlyBraced(e))throw new SyntaxError("Malformed Unicode: +"+e);const t=validateAndParseHex(e.slice(1,-1),"Malformed Unicode");try{return String.fromCodePoint(t)}catch(e){throw e instanceof RangeError?new SyntaxError("Code Point Limit:"+t):e}}const singleCharacterEscapes=new Map([["b","\b"],["f","\f"],["n","\n"],["r","\r"],["t","\t"],["v","\v"],["0","\0"]]);function parseSingleCharacterCode(e){return singleCharacterEscapes.get(e)||e}const escapeMatch=/\\(?:(\\)|x([\s\S]{0,2})|u(\{[^}]*\}?)|u([\s\S]{4})\\u([^{][\s\S]{0,3})|u([\s\S]{0,4})|([0-3]?[0-7]{1,2})|([\s\S])|$)/g;function unraw(e){return e.replace(escapeMatch,function(e,t,n,r,s,i,o,a,c){if(void 0!==t)return"\\";if(void 0!==n)return parseHexadecimalCode(n);if(void 0!==r)return parseUnicodeCodePointCode(r);if(void 0!==s)return parseUnicodeCode(s,i);if(void 0!==o)return parseUnicodeCode(o);if("0"===a)return"\0";if(void 0!==a)throw new SyntaxError("Octal Deprecation: "+a);if(void 0!==c)return parseSingleCharacterCode(c);throw new SyntaxError("End of string")})}let lispTypes=new Map;class ParseError extends Error{constructor(e,t){super(e+": "+t.substring(0,40)),this.code=t}}class Lisp{constructor(e){this.op=e.op,this.a=e.a,this.b=e.b}}class If{constructor(e,t){this.t=e,this.f=t}}class KeyVal{constructor(e,t){this.key=e,this.val=t}}class SpreadObject{constructor(e){this.item=e}}class SpreadArray{constructor(e){this.item=e}}const lispArrayKey={};function toLispArray(e){return e.lisp=lispArrayKey,e}const inlineIfElse=/^:/,elseIf=/^else(?![\w\$])/,ifElse=/^if(?![\w\$])/,space=/^\s/;let expectTypes={splitter:{types:{opHigh:/^(\/|\*\*|\*(?!\*)|\%)(?!\=)/,op:/^(\+(?!(\+))|\-(?!(\-)))(?!\=)/,comparitor:/^(<=|>=|<(?!<)|>(?!>)|!==|!=(?!\=)|===|==)/,boolOp:/^(&&|\|\||instanceof(?![\w\$])|in(?![\w\$]))/,bitwise:/^(&(?!&)|\|(?!\|)|\^|<<|>>(?!>)|>>>)(?!\=)/},next:["modifier","value","prop","incrementerBefore"]},inlineIf:{types:{inlineIf:/^\?(?!\.(?!\d))/},next:["expEnd"]},assignment:{types:{assignModify:/^(\-=|\+=|\/=|\*\*=|\*=|%=|\^=|\&=|\|=|>>>=|>>=|<<=)/,assign:/^(=)(?!=)/},next:["modifier","value","prop","incrementerBefore"]},incrementerBefore:{types:{incrementerBefore:/^(\+\+|\-\-)/},next:["prop"]},expEdge:{types:{call:/^(\?\.)?[\(]/,incrementerAfter:/^(\+\+|\-\-)/},next:["splitter","expEdge","dot","inlineIf","expEnd"]},modifier:{types:{not:/^!/,inverse:/^~/,negative:/^\-(?!\-)/,positive:/^\+(?!\+)/,typeof:/^typeof(?![\w\$])/,delete:/^delete(?![\w\$])/},next:["modifier","value","prop","incrementerBefore"]},dot:{types:{arrayProp:/^(\?\.)?\[/,dot:/^(\?)?\.(?=\s*[a-zA-Z\$\_])/},next:["splitter","assignment","expEdge","dot","inlineIf","expEnd"]},prop:{types:{prop:/^[a-zA-Z\$\_][a-zA-Z\d\$\_]*/},next:["splitter","assignment","expEdge","dot","inlineIf","expEnd"]},value:{types:{createObject:/^\{/,createArray:/^\[/,number:/^(0x[\da-f]+(_[\da-f]+)*|(\d+(_\d+)*(\.\d+(_\d+)*)?|\.\d+(_\d+)*))(e[\+\-]?\d+(_\d+)*)?(n)?(?!\d)/i,string:/^"(\d+)"/,literal:/^`(\d+)`/,regex:/^\/(\d+)\/r(?![\w\$])/,boolean:/^(true|false)(?![\w\$])/,null:/^null(?![\w\$])/,und:/^undefined(?![\w\$])/,arrowFunctionSingle:/^(async\s+)?([a-zA-Z\$_][a-zA-Z\d\$_]*)\s*=>\s*({)?/,arrowFunction:/^(async\s*)?\(\s*((\.\.\.)?\s*[a-zA-Z\$_][a-zA-Z\d\$_]*(\s*,\s*(\.\.\.)?\s*[a-zA-Z\$_][a-zA-Z\d\$_]*)*)?\s*\)\s*=>\s*({)?/,inlineFunction:/^(async\s+)?function(\s*[a-zA-Z\$_][a-zA-Z\d\$_]*)?\s*\(\s*((\.\.\.)?\s*[a-zA-Z\$_][a-zA-Z\d\$_]*(\s*,\s*(\.\.\.)?\s*[a-zA-Z\$_][a-zA-Z\d\$_]*)*)?\s*\)\s*{/,group:/^\(/,NaN:/^NaN(?![\w\$])/,Infinity:/^Infinity(?![\w\$])/,void:/^void(?![\w\$])\s*/,await:/^await(?![\w\$])\s*/,new:/^new(?![\w\$])\s*/,throw:/^throw(?![\w\$])\s*/},next:["splitter","expEdge","dot","inlineIf","expEnd"]},initialize:{types:{initialize:/^(var|let|const)\s+([a-zA-Z\$_][a-zA-Z\d\$_]*)\s*(=)?/,return:/^return(?![\w\$])/},next:["modifier","value","prop","incrementerBefore","expEnd"]},spreadObject:{types:{spreadObject:/^\.\.\./},next:["value","prop"]},spreadArray:{types:{spreadArray:/^\.\.\./},next:["value","prop"]},expEnd:{types:{},next:[]},expFunction:{types:{function:/^(async\s+)?function(\s*[a-zA-Z\$_][a-zA-Z\d\$_]*)\s*\(\s*((\.\.\.)?\s*[a-zA-Z\$_][a-zA-Z\d\$_]*(\s*,\s*(\.\.\.)?\s*[a-zA-Z\$_][a-zA-Z\d\$_]*)*)?\s*\)\s*{/},next:["expEdge","expEnd"]},expSingle:{types:{for:/^(([a-zA-Z\$\_][\w\$]*)\s*:)?\s*for\s*\(/,do:/^(([a-zA-Z\$\_][\w\$]*)\s*:)?\s*do(?![\w\$])\s*(\{)?/,while:/^(([a-zA-Z\$\_][\w\$]*)\s*:)?\s*while\s*\(/,loopAction:/^(break|continue)(?![\w\$])\s*([a-zA-Z\$\_][\w\$]*)?/,if:/^((([a-zA-Z\$\_][\w\$]*)\s*:)?\s*)if\s*\(/,try:/^try\s*{/,block:/^{/,switch:/^(([a-zA-Z\$\_][\w\$]*)\s*:)?\s*switch\s*\(/},next:["expEnd"]}},closings$1={"(":")","[":"]","{":"}","'":"'",'"':'"',"`":"`"};function testMultiple(e,t){let n;for(let r=0;r<t.length;r++){if(n=t[r].exec(e),n)break}return n}class CodeString{constructor(e){this.ref={str:""},e instanceof CodeString?(this.ref=e.ref,this.start=e.start,this.end=e.end):(this.ref.str=e,this.start=0,this.end=e.length)}substring(e,t){if(!this.length)return this;(e=this.start+e)<0&&(e=0),e>this.end&&(e=this.end),(t=void 0===t?this.end:this.start+t)<0&&(t=0),t>this.end&&(t=this.end);const n=new CodeString(this);return n.start=e,n.end=t,n}get length(){const e=this.end-this.start;return e<0?0:e}char(e){if(this.start!==this.end)return this.ref.str[this.start+e]}toString(){return this.ref.str.substring(this.start,this.end)}trimStart(){const e=/^\s+/.exec(this.toString()),t=new CodeString(this);return e&&(t.start+=e[0].length),t}slice(e,t){return e<0&&(e=this.end-this.start+e),e<0&&(e=0),void 0===t&&(t=this.end-this.start),t<0&&(t=this.end-this.start+t),t<0&&(t=0),this.substring(e,t)}trim(){const e=this.trimStart(),t=/\s+$/.exec(e.toString());return t&&(e.end-=t[0].length),e}valueOf(){return this.toString()}}const emptyString=new CodeString(""),okFirstChars=/^[\+\-~ !]/,aNumber=expectTypes.value.types.number,wordReg=/^((if|for|else|while|do|function)(?![\w\$])|[\w\$]+)/,semiColon=/^;/,insertedSemicolons=new WeakMap,quoteCache=new WeakMap;function restOfExp(e,t,n,r,s,i,o={}){if(!t.length)return t;o.words=o.words||[];let a=!0;const c=(n=n||[]).includes(semiColon);c&&(n=n.filter(e=>e!==semiColon));const l=insertedSemicolons.get(t.ref)||[],p=quoteCache.get(t.ref)||new Map;if(quoteCache.set(t.ref,p),r&&p.has(t.start-1))return t.substring(0,p.get(t.start-1)-t.start);let u,f=!1,d=!1,h="",g=!1,y=!1;for(u=0;u<t.length&&!d;u++){let b=t.char(u);if('"'===r||"'"===r||"`"===r){if("`"!==r||"$"!==b||"{"!==t.char(u+1)||f){if(b===r&&!f)return t.substring(0,u)}else{u+=restOfExp(e,t.substring(u+2),[],"{").length+2}f=!f&&"\\"===b}else if(closings$1[b]){if(!y&&l[u+t.start]){if(y=!0,c)break;u--,h=";";continue}if(g&&"{"===b&&(g=!1),b===s){d=!0;break}{let n=restOfExp(e,t.substring(u+1),[],b);if(p.set(n.start-1,n.end),u+=n.length+1,a=!1,i){let e;(e=testMultiple(t.substring(u).toString(),i))&&(o.regRes=e,d=!0)}}}else if(r){if(b===closings$1[r])return t.substring(0,u)}else{let e,r,s=t.substring(u).toString();if(i){let e;if(e=testMultiple(s,i)){o.regRes=e,u++,d=!0;break}}if(r=aNumber.exec(s))u+=r[0].length-1,s=t.substring(u).toString();else if(h!=b){let r;if(";"===b||l[u+t.start]&&!a&&!y){if(c)r=[";"];else if(l[u+t.start]){y=!0,u--,h=";";continue}b=s=";"}else y=!1;r||(r=testMultiple(s,n)),r&&(d=!0),!d&&(e=wordReg.exec(s))&&(g=!0,e[0].length>1&&(o.words.push(e[1]),o.lastAnyWord=e[1],e[2]&&(o.lastWord=e[2])),e[0].length>2&&(u+=e[0].length-2))}if(a&&(okFirstChars.test(s)?d=!1:a=!1),d)break}h=b}if(r)throw new SyntaxError("Unclosed '"+r+"'");return o&&(o.oneliner=g),t.substring(0,u)}restOfExp.next=["splitter","expEnd","inlineIf"];const startingExecpted=["initialize","expSingle","expFunction","value","modifier","prop","incrementerBefore","expEnd"],setLispType=(e,t)=>{e.forEach(e=>{lispTypes.set(e,t)})},closingsCreate={createArray:/^\]/,createObject:/^\}/,group:/^\)/,arrayProp:/^\]/,call:/^\)/};function extractIfElse(e,t){var n;let r,s,i=0,o=t.substring(0,0),a=emptyString,c=!0,l={};for(;(o=restOfExp(e,t.substring(o.end-t.start),[elseIf,ifElse,semiColon],void 0,void 0,void 0,l)).length||c;){c=!1;const p=t.substring(o.end-t.start).toString();if(p.startsWith("if"))o.end++,i++;else if(p.startsWith("else"))r=t.substring(0,o.end-t.start),o.end++,i--,i||o.end--;else{if(!(s=/^;?\s*else(?![\w\$])/.exec(p))){r=a.length?r:t.substring(0,o.end-t.start);break}r=t.substring(0,o.end-t.start),o.end+=s[0].length-1,i--,i||(o.end-=s[0].length-1)}if(!i){a=extractIfElse(e,t.substring(o.end-t.start+(null===(n=/^;?\s*else(?![\w\$])/.exec(p))||void 0===n?void 0:n[0].length))).all;break}l={}}return r=r||t.substring(0,o.end-t.start),{all:t.substring(0,Math.max(r.end,a.end)-t.start),true:r,false:a}}setLispType(["createArray","createObject","group","arrayProp","call"],(e,t,n,r,s,i)=>{let o=emptyString,a=[],c=!1,l=r[0].length;const p=l;for(;l<n.length&&!c;)o=restOfExp(e,n.substring(l),[closingsCreate[t],/^,/]),l+=o.length,o.length&&a.push(o),","!==n.char(l)?c=!0:l++;const u=["value","modifier","prop","incrementerBefore","expEnd"];let f,d;switch(t){case"group":case"arrayProp":f=lispifyExpr(e,n.substring(p,l));break;case"call":case"createArray":f=toLispArray(a.map(t=>lispify(e,t,[...u,"spreadArray"])));break;case"createObject":f=toLispArray(a.map(t=>{let n,r;if(t=t.trimStart(),d=expectTypes.expFunction.types.function.exec("function "+t),d)r=d[2].trimStart(),n=lispify(e,new CodeString("function "+t.toString().replace(r,"")));else{let s=restOfExp(e,t,[/^:/]);if(r=lispify(e,s,[...u,"spreadObject"]),r instanceof Lisp&&"prop"===r.op&&(r=r.b),s.length===t.length)return r;n=lispify(e,t.substring(s.length+1))}return new Lisp({op:"keyVal",a:r,b:n})}))}t="arrayProp"===t?r[1]?"?prop":"prop":"call"===t?r[1]?"?call":"call":t,i.lispTree=lispify(e,n.substring(l+1),expectTypes[s].next,new Lisp({op:t,a:i.lispTree,b:f}))}),setLispType(["inverse","not","negative","positive","typeof","delete"],(e,t,n,r,s,i)=>{let o=restOfExp(e,n.substring(r[0].length),[/^([^\s\.\?\w\$]|\?[^\.])/]);i.lispTree=lispify(e,n.substring(o.length+r[0].length),restOfExp.next,new Lisp({op:["positive","negative"].includes(t)?"$"+r[0]:r[0],a:i.lispTree,b:lispify(e,o,expectTypes[s].next)}))}),setLispType(["incrementerBefore"],(e,t,n,r,s,i)=>{let o=restOfExp(e,n.substring(2),[/^[^\s\.\w\$]/]);i.lispTree=lispify(e,n.substring(o.length+2),restOfExp.next,new Lisp({op:r[0]+"$",a:lispify(e,o,expectTypes[s].next)}))}),setLispType(["incrementerAfter"],(e,t,n,r,s,i)=>{i.lispTree=lispify(e,n.substring(r[0].length),expectTypes[s].next,new Lisp({op:"$"+r[0],a:i.lispTree}))}),setLispType(["assign","assignModify","boolOp"],(e,t,n,r,s,i)=>{i.lispTree=new Lisp({op:r[0],a:i.lispTree,b:lispify(e,n.substring(r[0].length),expectTypes[s].next)})}),setLispType(["opHigh","op","comparitor","bitwise"],(e,t,n,r,s,i)=>{const o=[expectTypes.inlineIf.types.inlineIf,inlineIfElse];switch(t){case"opHigh":o.push(expectTypes.splitter.types.opHigh);case"op":o.push(expectTypes.splitter.types.op);case"comparitor":o.push(expectTypes.splitter.types.comparitor);case"bitwise":o.push(expectTypes.splitter.types.bitwise),o.push(expectTypes.splitter.types.boolOp)}let a=restOfExp(e,n.substring(r[0].length),o);i.lispTree=lispify(e,n.substring(a.length+r[0].length),restOfExp.next,new Lisp({op:r[0],a:i.lispTree,b:lispify(e,a,expectTypes[s].next)}))}),setLispType(["inlineIf"],(e,t,n,r,s,i)=>{let o=!1,a=n.substring(0,0),c=1;for(;!o&&a.length<n.length;)a.end=restOfExp(e,n.substring(a.length+1),[expectTypes.inlineIf.types.inlineIf,inlineIfElse]).end,"?"===n.char(a.length)?c++:c--,c||(o=!0);a.start=n.start+1,i.lispTree=new Lisp({op:"?",a:i.lispTree,b:new If(lispifyExpr(e,a),lispifyExpr(e,n.substring(r[0].length+a.length+1)))})}),setLispType(["if"],(e,t,n,r,s,i)=>{let o=restOfExp(e,n.substring(r[0].length),[],"(");const a=extractIfElse(e,n.substring(r[1].length));/^\s*\{/.exec(n.substring(r[0].length+o.length+1).toString());const c=r[0].length-r[1].length+o.length+1;let l=a.true.substring(c),p=a.false;o=o.trim(),l=l.trim(),p=p.trim(),"{"===l.char(0)&&(l=l.slice(1,-1)),"{"===p.char(0)&&(p=p.slice(1,-1)),i.lispTree=new Lisp({op:"if",a:lispifyExpr(e,o),b:new If(lispifyBlock(l,e),p.length?lispifyBlock(p,e):void 0)})}),setLispType(["switch"],(e,t,n,r,s,i)=>{const o=restOfExp(e,n.substring(r[0].length),[],"(");let a=n.toString().indexOf("{",r[0].length+o.length+1);if(-1===a)throw new SyntaxError("Invalid switch");let c,l=insertSemicolons(e,restOfExp(e,n.substring(a+1),[],"{"));const p=/^\s*(case\s|default)\s*/;let u=[],f=!1;for(;c=p.exec(l.toString());){if("default"===c[1]){if(f)throw new SyntaxError("Only one default switch case allowed");f=!0}let t=restOfExp(e,l.substring(c[0].length),[/^:/]),n=emptyString,r=a=c[0].length+t.length+1,s=/^\s*\{/.exec(l.substring(r).toString()),i=[];if(s)r+=s[0].length,n=restOfExp(e,l.substring(r),[],"{"),r+=n.length+1,i=lispifyBlock(n,e);else{let t=restOfExp(e,l.substring(r),[p]);if(t.trim().length){for(;(n=restOfExp(e,l.substring(r),[semiColon])).length&&(r+=n.length+(";"===l.char(r+n.length)?1:0),!p.test(l.substring(r).toString())););i=lispifyBlock(l.substring(a,n.end-l.start),e)}else i=[],r+=t.length}l=l.substring(r),u.push(new Lisp({op:"case",a:"default"===c[1]?void 0:lispifyExpr(e,t),b:toLispArray(i)}))}i.lispTree=new Lisp({op:"switch",a:lispifyExpr(e,o),b:toLispArray(u)})}),setLispType(["dot","prop"],(e,t,n,r,s,i)=>{let o=r[0],a=r[0].length,c="prop";if("dot"===t){r[1]&&(c="?prop");let e=n.substring(r[0].length).toString().match(expectTypes.prop.types.prop);if(!e||!e.length)throw new SyntaxError("Hanging  dot");o=e[0],a=o.length+r[0].length}i.lispTree=lispify(e,n.substring(a),expectTypes[s].next,new Lisp({op:c,a:i.lispTree,b:o}))}),setLispType(["spreadArray","spreadObject"],(e,t,n,r,s,i)=>{i.lispTree=new Lisp({op:t,b:lispify(e,n.substring(r[0].length),expectTypes[s].next)})}),setLispType(["return","throw"],(e,t,n,r,s,i)=>{i.lispTree=new Lisp({op:t,b:lispifyExpr(e,n.substring(r[0].length))})});const primitives={true:!0,false:!1,null:null,Infinity:1/0,NaN:NaN,und:void 0};setLispType(["number","boolean","null","und","NaN","Infinity"],(e,t,n,r,s,i)=>{i.lispTree=lispify(e,n.substring(r[0].length),expectTypes[s].next,"number"===t?r[10]?BigInt(r[1]):Number(r[0]):primitives["boolean"===t?r[0]:t])}),setLispType(["string","literal","regex"],(e,t,n,r,s,i)=>{i.lispTree=lispify(e,n.substring(r[0].length),expectTypes[s].next,new Lisp({op:t,b:parseInt(JSON.parse(r[1]),10)}))}),setLispType(["initialize"],(e,t,n,r,s,i)=>{r[3]?i.lispTree=new Lisp({op:r[1],a:r[2],b:lispify(e,n.substring(r[0].length),expectTypes[s].next)}):i.lispTree=lispify(e,n.substring(r[0].length),expectTypes[s].next,new Lisp({op:r[1],a:r[2]}))}),setLispType(["function","inlineFunction","arrowFunction","arrowFunctionSingle"],(e,t,n,r,s,i)=>{const o="function"!==t&&"inlineFunction"!==t,a=o&&!r[r.length-1],c=o?2:3,l=!!r[1],p=r[c]?r[c].replace(/\s+/g,"").split(/,/g):[];o||p.unshift((r[2]||"").trimStart());let u=!1;p.forEach(e=>{if(u)throw new SyntaxError("Rest parameter must be last formal parameter");e.startsWith("...")&&(u=!0)}),p.unshift(l);const f=restOfExp(e,n.substring(r[0].length),a?[/^[,\)\}\]]/,semiColon]:[/^}/]),d=a?"return "+f:f;i.lispTree=lispify(e,n.substring(r[0].length+d.length+1),expectTypes[s].next,new Lisp({op:o?"arrowFunc":t,a:toLispArray(p),b:e.eager?lispifyFunction(new CodeString(d),e):d}))});const iteratorRegex=/^((let|var|const)\s+)?\s*([a-zA-Z\$_][a-zA-Z\d\$_]*)\s+(in|of)(?![\w\$])/;setLispType(["for","do","while"],(e,t,n,r,s,i)=>{let o,a,c,l=0,p=!0,u=toLispArray([]),f=!1,d=!0,h=!0;switch(t){case"while":l=n.toString().indexOf("(")+1;let t=restOfExp(e,n.substring(l),[],"(");a=lispifyReturnExpr(e,t),c=restOfExp(e,n.substring(l+t.length+1)).trim(),"{"===c[0]&&(c=c.slice(1,-1));break;case"for":l=n.toString().indexOf("(")+1;let s,i=[],g=emptyString;for(let t=0;t<3&&(g=restOfExp(e,n.substring(l),[/^[;\)]/]),i.push(g.trim()),l+=g.length+1,")"!==n.char(l-1));t++);if(1===i.length&&(s=iteratorRegex.exec(i[0].toString())))"of"===s[4]?(o=lispifyReturnExpr(e,i[0].substring(s[0].length)),u=toLispArray([ofStart2,ofStart3]),a=ofCondition,h=ofStep,f=lispify(e,new CodeString((s[1]||"let ")+s[3]+" = $$next.value"),["initialize"])):(o=lispifyReturnExpr(e,i[0].substring(s[0].length)),u=toLispArray([inStart2,inStart3]),h=inStep,a=inCondition,f=lispify(e,new CodeString((s[1]||"let ")+s[3]+" = $$keys[$$keyIndex]"),["initialize"]));else{if(3!==i.length)throw new SyntaxError("Invalid for loop definition");p=lispifyExpr(e,i.shift(),startingExecpted),a=lispifyReturnExpr(e,i.shift()),h=lispifyExpr(e,i.shift())}c=restOfExp(e,n.substring(l)).trim(),"{"===c[0]&&(c=c.slice(1,-1));break;case"do":d=!1;const y=!!r[3];c=restOfExp(e,n.substring(r[0].length),y?[/^\}/]:[semiColon]),a=lispifyReturnExpr(e,restOfExp(e,n.substring(n.toString().indexOf("(",r[0].length+c.length)+1),[],"("))}const g=toLispArray([d,u,o,p,h,a,f]);i.lispTree=new Lisp({op:"loop",a:g,b:lispifyBlock(c,e)})}),setLispType(["block"],(e,t,n,r,s,i)=>{i.lispTree=lispifyBlock(restOfExp(e,n.substring(1),[],"{"),e)}),setLispType(["loopAction"],(e,t,n,r,s,i)=>{i.lispTree=new Lisp({op:"loopAction",a:r[1]})});const catchReg=/^\s*(catch\s*(\(\s*([a-zA-Z\$_][a-zA-Z\d\$_]*)\s*\))?|finally)\s*\{/;setLispType(["try"],(e,t,n,r,s,i)=>{const o=restOfExp(e,n.substring(r[0].length),[],"{");let a,c,l,p=catchReg.exec(n.substring(r[0].length+o.length+1).toString()),u=0;p[1].startsWith("catch")?(p=catchReg.exec(n.substring(r[0].length+o.length+1).toString()),c=p[2],l=restOfExp(e,n.substring(r[0].length+o.length+1+p[0].length),[],"{"),u=r[0].length+o.length+1+p[0].length+l.length+1,(p=catchReg.exec(n.substring(u).toString()))&&p[1].startsWith("finally")&&(a=restOfExp(e,n.substring(u+p[0].length),[],"{"))):a=restOfExp(e,n.substring(r[0].length+o.length+1+p[0].length),[],"{");const f=toLispArray([c,lispifyBlock(insertSemicolons(e,l||emptyString),e),lispifyBlock(insertSemicolons(e,a||emptyString),e)]);i.lispTree=new Lisp({op:"try",a:lispifyBlock(insertSemicolons(e,o),e),b:f})}),setLispType(["void","await"],(e,t,n,r,s,i)=>{const o=restOfExp(e,n.substring(r[0].length),[/^([^\s\.\?\w\$]|\?[^\.])/]);i.lispTree=lispify(e,n.substring(r[0].length+o.length),expectTypes[s].next,new Lisp({op:t,a:lispify(e,o)}))}),setLispType(["new"],(e,t,n,r,s,i)=>{let o=r[0].length;const a=restOfExp(e,n.substring(o),[],void 0,"(");o+=a.length+1;const c=[];if("("===n.char(o-1)){const t=restOfExp(e,n.substring(o),[],"(");let r;o+=t.length+1;let s=0;for(;(r=restOfExp(e,t.substring(s),[/^,/])).length;)s+=r.length+1,c.push(r.trim())}i.lispTree=lispify(e,n.substring(o),expectTypes.expEdge.next,new Lisp({op:t,a:lispify(e,a,expectTypes.initialize.next),b:toLispArray(c.map(t=>lispify(e,t,expectTypes.initialize.next)))}))});const ofStart2=lispify(void 0,new CodeString("let $$iterator = $$obj[Symbol.iterator]()"),["initialize"]),ofStart3=lispify(void 0,new CodeString("let $$next = $$iterator.next()"),["initialize"]),ofCondition=lispify(void 0,new CodeString("return !$$next.done"),["initialize"]),ofStep=lispify(void 0,new CodeString("$$next = $$iterator.next()")),inStart2=lispify(void 0,new CodeString("let $$keys = Object.keys($$obj)"),["initialize"]),inStart3=lispify(void 0,new CodeString("let $$keyIndex = 0"),["initialize"]),inStep=lispify(void 0,new CodeString("$$keyIndex++")),inCondition=lispify(void 0,new CodeString("return $$keyIndex < $$keys.length"),["initialize"]);var lastType;function lispify(e,t,n,r,s=!1){if(n=n||expectTypes.initialize.next,void 0===t)return r;const i=(t=t.trimStart()).toString();if(!t.length&&!n.includes("expEnd"))throw new SyntaxError("Unexpected end of expression");if(!t.length)return r;let o,a={lispTree:r};for(let r of n)if("expEnd"!==r){for(let n in expectTypes[r].types)if("expEnd"!==n&&(o=expectTypes[r].types[n].exec(i))){lastType=n;try{lispTypes.get(n)(e,n,t,o,r,a)}catch(e){if(s&&e instanceof SyntaxError)throw new ParseError(e.message,i);throw e}break}if(o)break}if(!o&&t.length){if(t.char(0),s)throw new ParseError(`Unexpected token after ${lastType}: ${t.char(0)}`,i);throw new SyntaxError(`Unexpected token after ${lastType}: ${t.char(0)}`)}return a.lispTree}const startingExpectedWithoutSingle=startingExecpted.filter(e=>"expSingle"!==e);function lispifyExpr(e,t,n){if(!t.trimStart().length)return;let r,s=[],i=0;if((n=n||expectTypes.initialize.next).includes("expSingle")&&testMultiple(t.toString(),Object.values(expectTypes.expSingle.types)))return lispify(e,t,["expSingle"],void 0,!0);for(n===startingExecpted&&(n=startingExpectedWithoutSingle);(r=restOfExp(e,t.substring(i),[/^,/])).length;)s.push(r.trimStart()),i+=r.length+1;if(1===s.length)return lispify(e,t,n,void 0,!0);if(n.includes("initialize")){let r=expectTypes.initialize.types.initialize.exec(s[0].toString());if(r)return toLispArray(s.map((t,n)=>lispify(e,n?new CodeString(r[1]+" "+t):t,["initialize"],void 0,!0)));if(expectTypes.initialize.types.return.exec(s[0].toString()))return lispify(e,t,n,void 0,!0)}const o=toLispArray(s.map((t,r)=>lispify(e,t,n,void 0,!0)));return new Lisp({op:"multi",a:o})}function lispifyReturnExpr(e,t){return new Lisp({op:"return",b:lispifyExpr(e,t)})}function lispifyBlock(e,t,n=!1){if(!(e=insertSemicolons(t,e)).trim().length)return toLispArray([]);let r,s=[],i=0,o=0,a={},c=!1,l=!1;for(;(r=restOfExp(t,e.substring(i),[semiColon],void 0,void 0,void 0,a)).length&&(l=e.char(i+r.length)&&";"!==e.char(i+r.length),i+=r.length+(l?0:1),/^\s*else(?![\w\$])/.test(e.substring(i).toString())||a.words.includes("do")&&/^\s*while(?![\w\$])/.test(e.substring(i).toString())?c=!0:(c=!1,s.push(e.substring(o,i-(l?0:1))),o=i),a={},!n););return c&&s.push(e.substring(o,i-(l?0:1))),toLispArray(s.map(e=>e.trimStart()).filter(e=>e.length).map((e,n)=>lispifyExpr(t,e.trimStart(),startingExecpted)).flat())}function lispifyFunction(e,t,n=!1){if(!e.trim().length)return toLispArray([]);const r=lispifyBlock(e,t,n);let s=toLispArray([]);return hoist(r,s),toLispArray(s.concat(r))}function hoist(e,t){if(Array.isArray(e)){const n=[];for(let r of e)hoist(r,t)||n.push(r);n.length!==e.length&&(e.length=0,e.push(...n))}else if(e instanceof Lisp)if("try"===e.op||"if"===e.op||"loop"===e.op||"switch"===e.op)hoist(e.a,t),hoist(e.b,t);else if("var"===e.op)t.push(new Lisp({op:"var",a:e.a}));else if("function"===e.op&&e.a[1])return t.push(e),!0;return!1}const closingsNoInsertion=/^(\})\s*(catch|finally|else|while|instanceof)(?![\w\$])/,colonsRegex=/^((([\w\$\]\)\"\'\`]|\+\+|\-\-)\s*\r?\n\s*([\w\$\+\-\!~]))|(\}\s*[\w\$\!~\+\-\{\(\"\'\`]))/;function insertSemicolons(e,t){let n=t,r=emptyString,s={};const i=insertedSemicolons.get(t.ref)||new Array(t.ref.str.length);for(;(r=restOfExp(e,n,[],void 0,void 0,[colonsRegex],s)).length;){let e=!1,t=r,o=r.length;if(s.regRes){e=!0;const[,,i,,,a]=s.regRes;if(o="++"===s.regRes[3]||"--"===s.regRes[3]?r.length+1:r.length,t=n.substring(0,o),a){let t=closingsNoInsertion.exec(n.substring(r.length-1).toString());t?e="while"===t[2]&&"do"!==s.lastWord:"function"===s.lastWord&&"}"===s.regRes[5][0]&&"("===s.regRes[5].slice(-1)&&(e=!1)}else i&&("if"!==s.lastWord&&"while"!==s.lastWord&&"for"!==s.lastWord&&"else"!==s.lastWord||(e=!1))}e&&(i[t.end]=!0),n=n.substring(o),s={}}return insertedSemicolons.set(t.ref,i),t}function checkRegex(e){let t=1,n=!1,r=!1,s=!1;for(;t<e.length&&!r&&!s;)r="/"===e[t]&&!n,n="\\"===e[t]&&!n,s="\n"===e[t],t++;let i=e.substring(t);if(s=s||!r||/^\s*\d/.test(i),s)return null;let o=/^[a-z]*/.exec(i);return/^\s+[\w\$]/.test(e.substring(t+o[0].length))?null:{regex:e.substring(1,t-1),flags:o&&o[0]||"",length:t+(o&&o[0].length||0)}}const notDivide=/(typeof|delete|instanceof|return|in|of|throw|new|void|do|if)$/,possibleDivide=/^([\w\$\]\)]|\+\+|\-\-)[\s\/]/;function extractConstants(e,t,n=""){let r,s,i=[],o=!1,a="",c=-1,l=toLispArray([]),p="";const u=[],f=[];let d;for(var h=0;h<t.length;h++)if(p=t[h],a)p===a&&("*"===a&&"/"===t[h+1]?(a="",h++):"\n"===a&&(a=""));else{if(o){o=!1,i.push(p);continue}if(r)if("`"===r&&"$"===p&&"{"===t[h+1]){let n=extractConstants(e,t.substring(h+2),"{");l.push(n.str),i.push("${",l.length-1,"}"),h+=n.length+2}else r===p?("`"===r?(e.literals.push({op:"literal",a:unraw(i.join("")),b:l}),u.push("`",e.literals.length-1,"`")):(e.strings.push(unraw(i.join(""))),u.push('"',e.strings.length-1,'"')),r=null,i=[]):i.push(p);else{if("'"===p||'"'===p||"`"===p)l=toLispArray([]),r=p;else{if(closings$1[n]===p&&!f.length)return{str:u.join(""),length:h};closings$1[p]?(f.push(p),u.push(p)):closings$1[f[f.length-1]]===p?(f.pop(),u.push(p)):"/"!==p||"*"!==t[h+1]&&"/"!==t[h+1]?"/"===p&&!d&&(s=checkRegex(t.substring(h)))?(e.regexes.push(s),u.push("/",e.regexes.length-1,"/r"),h+=s.length-1):u.push(p):(a="*"===t[h+1]?"*":"\n",c=h)}d&&space.test(p)||(d=possibleDivide.exec(t.substring(h)))&&notDivide.test(t.substring(0,h+d[1].length))&&(d=null)}o=r&&"\\"===p}if(a&&"*"===a)throw new SyntaxError(`Unclosed comment '/*': ${t.substring(c)}`);return{str:u.join(""),length:h}}function parse(e,t=!1,n=!1){if("string"!=typeof e)throw new ParseError(`Cannot parse ${e}`,e);let r=" "+e;const s={strings:[],literals:[],regexes:[],eager:t};r=extractConstants(s,r).str;for(let e of s.literals)e.b=toLispArray(e.b.map(e=>lispifyExpr(s,new CodeString(e))));return{tree:lispifyFunction(new CodeString(r),s,n),constants:s}}class ExecReturn{constructor(e,t,n,r=!1,s=!1){this.auditReport=e,this.result=t,this.returned=n,this.breakLoop=r,this.continueLoop=s}}class Prop{constructor(e,t,n=!1,r=!1,s=!1){this.context=e,this.prop=t,this.isConst=n,this.isGlobal=r,this.isVariable=s}get(e){if(void 0===this.context)throw new ReferenceError(`${this.prop} is not defined`);return e.getSubscriptions.forEach(e=>e(this.context,this.prop)),this.context[this.prop]}}const optional={},reservedWords=new Set(["instanceof","typeof","return","try","catch","if","finally","else","in","of","var","let","const","for","delete","false","true","while","do","break","continue","new","function","async","await","switch","case"]);var VarType;function keysOnly(e){const t=Object.assign({},e);for(let e in t)t[e]=!0;return t}!function(e){e.let="let",e.const="const",e.var="var"}(VarType||(VarType={}));class Scope{constructor(e,t={},n){this.const={},this.let={},this.var={};const r=void 0!==n||null===e;this.parent=e,this.allVars=t,this.let=r?this.let:keysOnly(t),this.var=r?keysOnly(t):this.var,this.globals=null===e?keysOnly(t):{},this.functionThis=n}get(e,t=!1){if("this"===e&&void 0!==this.functionThis)return new Prop({this:this.functionThis},e,!0,!1,!0);if(reservedWords.has(e))throw new SyntaxError("Unexepected token '"+e+"'");if(null===this.parent||!t||void 0!==this.functionThis){if(this.globals.hasOwnProperty(e))return new Prop(this.functionThis,e,!1,!0,!0);if(e in this.allVars&&(!(e in{})||this.allVars.hasOwnProperty(e)))return new Prop(this.allVars,e,this.const.hasOwnProperty(e),this.globals.hasOwnProperty(e),!0);if(null===this.parent)return new Prop(void 0,e)}return this.parent.get(e,t)}set(e,t){if("this"===e)throw new SyntaxError('"this" cannot be assigned');if(reservedWords.has(e))throw new SyntaxError("Unexepected token '"+e+"'");let n=this.get(e);if(void 0===n.context)throw new ReferenceError(`Variable '${e}' was not declared.`);if(n.isConst)throw new TypeError(`Cannot assign to const variable '${e}'`);if(n.isGlobal)throw new SandboxError(`Cannot override global variable '${e}'`);return n.context[n.prop]=t,n}declare(e,t=null,n=void 0,r=!1){if("this"===e)throw new SyntaxError('"this" cannot be declared');if(reservedWords.has(e))throw new SyntaxError("Unexepected token '"+e+"'");if("var"===t&&void 0===this.functionThis&&null!==this.parent)return this.parent.declare(e,t,n,r);if((!this[t].hasOwnProperty(e)||"const"===t||this.globals.hasOwnProperty(e))&&e in this.allVars)throw new SandboxError(`Identifier '${e}' has already been declared`);return r&&(this.globals[e]=!0),this[t][e]=!0,this.allVars[e]=n,new Prop(this.allVars,e,this.const.hasOwnProperty(e),r)}}class LocalScope{}class SandboxError extends Error{}let currentTicks;function sandboxFunction(e,t){return function(...n){let r=parse(n.pop()||"");return createFunction(n,r.tree,t||currentTicks,{...e,constants:r.constants,tree:r.tree},void 0,"anonymous")}}function generateArgs(e,t){const n={};return e.forEach((e,r)=>{e.startsWith("...")?n[e.substring(3)]=t.slice(r):n[e]=t[r]}),n}const sandboxedFunctions=new WeakSet;function createFunction(e,t,n,r,s,i){if(r.ctx.options.forbidFunctionCreation)throw new SandboxError("Function creation is forbidden");let o;return o=void 0===i?(...i)=>{const o=generateArgs(e,i);return executeTree(n,r,t,void 0===s?[]:[new Scope(s,o)]).result}:function(...i){const o=generateArgs(e,i);return executeTree(n,r,t,void 0===s?[]:[new Scope(s,o,this)]).result},r.registerSandboxFunction(o),sandboxedFunctions.add(o),o}function createFunctionAsync(e,t,n,r,s,i){var o;if(r.ctx.options.forbidFunctionCreation)throw new SandboxError("Function creation is forbidden");if(!(null===(o=r.ctx.prototypeWhitelist)||void 0===o?void 0:o.has(Promise.prototype)))throw new SandboxError("Async/await not permitted");let a;return a=void 0===i?async(...i)=>{const o=generateArgs(e,i);return(await executeTreeAsync(n,r,t,void 0===s?[]:[new Scope(s,o)])).result}:async function(...i){const o=generateArgs(e,i);return(await executeTreeAsync(n,r,t,void 0===s?[]:[new Scope(s,o,this)])).result},r.registerSandboxFunction(a),sandboxedFunctions.add(a),a}function sandboxedEval(e){return function(t){return e(t)()}}function sandboxedSetTimeout(e){return function(t,...n){return"string"!=typeof t?setTimeout(t,...n):setTimeout(e(t),...n)}}function sandboxedSetInterval(e){return function(t,...n){return"string"!=typeof t?setInterval(t,...n):setInterval(e(t),...n)}}function assignCheck(e,t,n="assign"){var r,s,i,o,a,c,l,p;if(void 0===e.context)throw new ReferenceError(`Cannot ${n} value to undefined.`);if("object"!=typeof e.context&&"function"!=typeof e.context)throw new SyntaxError(`Cannot ${n} value to a primitive.`);if(e.isConst)throw new TypeError(`Cannot set value to const variable '${e.prop}'`);if(e.isGlobal)throw new SandboxError(`Cannot ${n} property '${e.prop}' of a global object`);if("function"==typeof e.context[e.prop]&&!e.context.hasOwnProperty(e.prop))throw new SandboxError(`Override prototype property '${e.prop}' not allowed`);"delete"===n?e.context.hasOwnProperty(e.prop)&&(null===(r=t.changeSubscriptions.get(e.context))||void 0===r||r.forEach(t=>t({type:"delete",prop:e.prop})),null===(s=t.changeSubscriptionsGlobal.get(e.context))||void 0===s||s.forEach(t=>t({type:"delete",prop:e.prop}))):e.context.hasOwnProperty(e.prop)?(null===(o=null===(i=t.setSubscriptions.get(e.context))||void 0===i?void 0:i.get(e.prop))||void 0===o||o.forEach(e=>e({type:"replace"})),null===(c=null===(a=t.setSubscriptionsGlobal.get(e.context))||void 0===a?void 0:a.get(e.prop))||void 0===c||c.forEach(e=>e({type:"replace"}))):(null===(l=t.changeSubscriptions.get(e.context))||void 0===l||l.forEach(t=>t({type:"create",prop:e.prop})),null===(p=t.changeSubscriptionsGlobal.get(e.context))||void 0===p||p.forEach(t=>t({type:"create",prop:e.prop})))}const arrayChange=new Set([[].push,[].pop,[].shift,[].unshift,[].splice,[].reverse,[].sort,[].copyWithin]),literalRegex=/(\$\$)*(\$)?\${(\d+)}/g;let ops2={prop:(e,t,n,r,s,i,o,a)=>{if(null===r)throw new TypeError(`Cannot get property ${s} of null`);const c=typeof r;if("undefined"===c&&void 0===i){let e=a.get(s);if(e.context===o.ctx.sandboxGlobal){o.ctx.options.audit&&o.ctx.auditReport.globalsAccess.add(s);const e=o.ctx.globalsWhitelist.has(o.ctx.sandboxGlobal[s])?o.evals.get(o.ctx.sandboxGlobal[s]):void 0;if(e)return void t(void 0,e)}return e.context&&e.context[s]===globalThis?void t(void 0,o.ctx.globalScope.get("this")):void t(void 0,e)}if(void 0===r)throw new SandboxError("Cannot get property '"+s+"' of undefined");if("object"!==c)"number"===c?r=new Number(r):"string"===c?r=new String(r):"boolean"===c&&(r=new Boolean(r));else if(void 0===r.hasOwnProperty)return void t(void 0,new Prop(void 0,s));const l="function"===c;let p=l||!(r.hasOwnProperty(s)||"number"==typeof s);if(o.ctx.options.audit&&p&&"string"==typeof s){let e=Object.getPrototypeOf(r);do{e.hasOwnProperty(s)&&(o.ctx.auditReport.prototypeAccess[e.constructor.name]||(o.ctx.auditReport.prototypeAccess[e.constructor.name]=new Set),o.ctx.auditReport.prototypeAccess[e.constructor.name].add(s))}while(e=Object.getPrototypeOf(e))}if(p)if(l){if(!["name","length","constructor"].includes(s)&&r.hasOwnProperty(s)){const e=o.ctx.prototypeWhitelist.get(r.prototype),n=o.ctx.options.prototypeReplacements.get(r);if(n)return void t(void 0,new Prop(n(r,!0),s));if(!e||e.size&&!e.has(s))throw new SandboxError(`Static method or property access not permitted: ${r.name}.${s}`)}}else if("constructor"!==s){let e=r;for(;e=Object.getPrototypeOf(e);)if(e.hasOwnProperty(s)){const n=o.ctx.prototypeWhitelist.get(e),i=o.ctx.options.prototypeReplacements.get(e.constuctor);if(i)return void t(void 0,new Prop(i(r,!1),s));if(n&&(!n.size||n.has(s)))break;throw new SandboxError(`Method or property access not permitted: ${e.constructor.name}.${s}`)}}if(o.evals.has(r[s]))return void t(void 0,o.evals.get(r[s]));if(r[s]===globalThis)return void t(void 0,o.ctx.globalScope.get("this"));let u=i.isGlobal||l&&!sandboxedFunctions.has(r)||o.ctx.globalsWhitelist.has(r);t(void 0,new Prop(r,s,!1,u))},call:(e,t,n,r,s,i,o,a)=>{if(o.ctx.options.forbidFunctionCalls)throw new SandboxError("Function invocations are not allowed");if("function"!=typeof r)throw new TypeError(`${i.prop} is not a function`);execMany(n,e,toLispArray(s.map(e=>e instanceof SpreadArray?[...e.item]:[e]).flat()),(e,n)=>{var r,s;if(e)t(e);else if("function"!=typeof i){if(i.context[i.prop]===JSON.stringify&&o.getSubscriptions.size){const e=new Set,t=n=>{if(n&&"object"==typeof n&&!e.has(n)){e.add(n);for(let e in n)o.getSubscriptions.forEach(t=>t(n,e)),t(n[e])}};t(n[0])}if(i.context instanceof Array&&arrayChange.has(i.context[i.prop])&&(o.changeSubscriptions.get(i.context)||o.changeSubscriptionsGlobal.get(i.context))){let e,t=!1;if("push"===i.prop)e={type:"push",added:n},t=!!n.length;else if("pop"===i.prop)e={type:"pop",removed:i.context.slice(-1)},t=!!e.removed.length;else if("shift"===i.prop)e={type:"shift",removed:i.context.slice(0,1)},t=!!e.removed.length;else if("unshift"===i.prop)e={type:"unshift",added:n},t=!!n.length;else if("splice"===i.prop)e={type:"splice",startIndex:n[0],deleteCount:void 0===n[1]?i.context.length:n[1],added:n.slice(2),removed:i.context.slice(n[0],void 0===n[1]?void 0:n[0]+n[1])},t=!!e.added.length||!!e.removed.length;else if("reverse"===i.prop||"sort"===i.prop)e={type:i.prop},t=!!i.context.length;else if("copyWithin"===i.prop){let r=void 0===n[2]?i.context.length-n[1]:Math.min(i.context.length,n[2]-n[1]);e={type:"copyWithin",startIndex:n[0],endIndex:n[0]+r,added:i.context.slice(n[1],n[1]+r),removed:i.context.slice(n[0],n[0]+r)},t=!!e.added.length||!!e.removed.length}t&&(null===(r=o.changeSubscriptions.get(i.context))||void 0===r||r.forEach(t=>t(e)),null===(s=o.changeSubscriptionsGlobal.get(i.context))||void 0===s||s.forEach(t=>t(e)))}i.get(o),t(void 0,i.context[i.prop](...n))}else t(void 0,i(...n))},a,o)},createObject:(e,t,n,r,s,i,o,a)=>{let c={};for(let e of s)e instanceof SpreadObject?c={...c,...e.item}:c[e.key]=e.val;t(void 0,c)},keyVal:(e,t,n,r,s)=>t(void 0,new KeyVal(r,s)),createArray:(e,t,n,r,s,i,o,a)=>{execMany(n,e,toLispArray(s.map(e=>e instanceof SpreadArray?[...e.item]:[e]).flat()),t,a,o)},group:(e,t,n,r,s)=>t(void 0,s),string:(e,t,n,r,s,i,o)=>t(void 0,o.constants.strings[s]),regex:(e,t,n,r,s,i,o)=>{const a=o.constants.regexes[s];if(!o.ctx.globalsWhitelist.has(RegExp))throw new SandboxError("Regex not permitted");t(void 0,new RegExp(a.regex,a.flags))},literal:(e,t,n,r,s,i,o,a)=>{let c,l=o.constants.literals[s].a,p=toLispArray([]),u=[];for(;c=literalRegex.exec(l);)c[2]||(p.push(o.constants.literals[s].b[parseInt(c[3],10)]),u.push(c[3]));execMany(n,e,p,(e,n)=>{const r={};if(e)t(e);else{for(let e in u){const t=u[e];r[t]=n[e]}t(void 0,l.replace(/(\\\\)*(\\)?\${(\d+)}/g,(e,t,n,s)=>{if(n)return e;return(t||"")+`${valueOrProp(r[s],o)}`}))}},a,o)},spreadArray:(e,t,n,r,s,i,o,a)=>{e(n,s,a,o,(e,n)=>{e?t(e):t(void 0,new SpreadArray(n))})},spreadObject:(e,t,n,r,s,i,o,a)=>{e(n,s,a,o,(e,n)=>{e?t(e):t(void 0,new SpreadObject(n))})},"!":(e,t,n,r,s)=>t(void 0,!s),"~":(e,t,n,r,s)=>t(void 0,~s),"++$":(e,t,n,r,s,i,o)=>{assignCheck(i,o),t(void 0,++i.context[i.prop])},"$++":(e,t,n,r,s,i,o)=>{assignCheck(i,o),t(void 0,i.context[i.prop]++)},"--$":(e,t,n,r,s,i,o)=>{assignCheck(i,o),t(void 0,--i.context[i.prop])},"$--":(e,t,n,r,s,i,o)=>{assignCheck(i,o),t(void 0,i.context[i.prop]--)},"=":(e,t,n,r,s,i,o)=>{assignCheck(i,o),t(void 0,i.context[i.prop]=s)},"+=":(e,t,n,r,s,i,o)=>{assignCheck(i,o),t(void 0,i.context[i.prop]+=s)},"-=":(e,t,n,r,s,i,o)=>{assignCheck(i,o),t(void 0,i.context[i.prop]-=s)},"/=":(e,t,n,r,s,i,o)=>{assignCheck(i,o),t(void 0,i.context[i.prop]/=s)},"*=":(e,t,n,r,s,i,o)=>{assignCheck(i,o),t(void 0,i.context[i.prop]*=s)},"**=":(e,t,n,r,s,i,o)=>{assignCheck(i,o),t(void 0,i.context[i.prop]**=s)},"%=":(e,t,n,r,s,i,o)=>{assignCheck(i,o),t(void 0,i.context[i.prop]%=s)},"^=":(e,t,n,r,s,i,o)=>{assignCheck(i,o),t(void 0,i.context[i.prop]^=s)},"&=":(e,t,n,r,s,i,o)=>{assignCheck(i,o),t(void 0,i.context[i.prop]&=s)},"|=":(e,t,n,r,s,i,o)=>{assignCheck(i,o),t(void 0,i.context[i.prop]|=s)},"<<=":(e,t,n,r,s,i,o)=>{assignCheck(i,o),t(void 0,i.context[i.prop]<<=s)},">>=":(e,t,n,r,s,i,o)=>{assignCheck(i,o),t(void 0,i.context[i.prop]>>=s)},">>>=":(e,t,n,r,s,i,o)=>{assignCheck(i,o),t(void 0,i.context[i.prop]>>=s)},"?":(e,t,n,r,s,i,o,a)=>{if(!(s instanceof If))throw new SyntaxError("Invalid inline if");e(n,r,a,o,(r,i)=>{r?t(r):e(n,valueOrProp(i,o)?s.t:s.f,a,o,t)})},">":(e,t,n,r,s)=>t(void 0,r>s),"<":(e,t,n,r,s)=>t(void 0,r<s),">=":(e,t,n,r,s)=>t(void 0,r>=s),"<=":(e,t,n,r,s)=>t(void 0,r<=s),"==":(e,t,n,r,s)=>t(void 0,r==s),"===":(e,t,n,r,s)=>t(void 0,r===s),"!=":(e,t,n,r,s)=>t(void 0,r!=s),"!==":(e,t,n,r,s)=>t(void 0,r!==s),"&&":(e,t,n,r,s)=>t(void 0,r&&s),"||":(e,t,n,r,s)=>t(void 0,r||s),"&":(e,t,n,r,s)=>t(void 0,r&s),"|":(e,t,n,r,s)=>t(void 0,r|s),":":(e,t,n,r,s)=>t(void 0,new If(r,s)),"+":(e,t,n,r,s)=>t(void 0,r+s),"-":(e,t,n,r,s)=>t(void 0,r-s),"$+":(e,t,n,r,s)=>t(void 0,+s),"$-":(e,t,n,r,s)=>t(void 0,-s),"/":(e,t,n,r,s)=>t(void 0,r/s),"^":(e,t,n,r,s)=>t(void 0,r^s),"*":(e,t,n,r,s)=>t(void 0,r*s),"%":(e,t,n,r,s)=>t(void 0,r%s),"<<":(e,t,n,r,s)=>t(void 0,r<<s),">>":(e,t,n,r,s)=>t(void 0,r>>s),">>>":(e,t,n,r,s)=>t(void 0,r>>>s),typeof:(e,t,n,r,s,i,o,a)=>{e(n,s,a,o,(e,n)=>{t(void 0,typeof valueOrProp(n,o))})},instanceof:(e,t,n,r,s)=>t(void 0,r instanceof s),in:(e,t,n,r,s)=>t(void 0,r in s),delete:(e,t,n,r,s,i,o,a,c)=>{void 0!==c.context?(assignCheck(c,o,"delete"),c.isVariable?t(void 0,!1):t(void 0,delete c.context[c.prop])):t(void 0,!0)},return:(e,t,n,r,s,i,o)=>t(void 0,s),var:(e,t,n,r,s,i,o,a,c)=>{e(n,s,a,o,(e,n)=>{e?t(e):t(void 0,a.declare(r,VarType.var,n))})},let:(e,t,n,r,s,i,o,a,c)=>{e(n,s,a,o,(e,n)=>{e?t(e):t(void 0,a.declare(r,VarType.let,n,c&&c.isGlobal))})},const:(e,t,n,r,s,i,o,a,c)=>{e(n,s,a,o,(e,n)=>{e?t(e):t(void 0,a.declare(r,VarType.const,n))})},arrowFunc:(e,t,n,r,s,i,o,a)=>{r=[...r],("string"==typeof i.b||i.b instanceof CodeString)&&(i.b=s=lispifyFunction(new CodeString(i.b),o.constants)),r.shift()?t(void 0,createFunctionAsync(r,s,n,o,a)):t(void 0,createFunction(r,s,n,o,a))},function:(e,t,n,r,s,i,o,a)=>{("string"==typeof i.b||i.b instanceof CodeString)&&(i.b=s=lispifyFunction(new CodeString(i.b),o.constants));let c,l=r.shift(),p=r.shift();c=l?createFunctionAsync(r,s,n,o,a,p):createFunction(r,s,n,o,a,p),p&&a.declare(p,VarType.var,c),t(void 0,c)},inlineFunction:(e,t,n,r,s,i,o,a)=>{("string"==typeof i.b||i.b instanceof CodeString)&&(i.b=s=lispifyFunction(new CodeString(i.b),o.constants));let c,l=r.shift(),p=r.shift();p&&(a=new Scope(a,{})),c=l?createFunctionAsync(r,s,n,o,a,p):createFunction(r,s,n,o,a,p),p&&a.declare(p,VarType.let,c),t(void 0,c)},loop:(e,t,n,r,s,i,o,a)=>{const[c,l,p,u,f,d,h]=r;let g=!0;const y=new Scope(a,{});let b={$$obj:void 0};const m=new Scope(y,b);if(e===execAsync)(async()=>{let r;for(r=asyncDone(t=>e(n,u,y,o,t)),b.$$obj=!0===(r=asyncDone(t=>e(n,p,y,o,t))).isInstant?r.instant:(await r.p).result,r=asyncDone(t=>e(n,l,m,o,t)),c&&(g=!0===(r=asyncDone(t=>e(n,d,m,o,t))).isInstant?r.instant:(await r.p).result);g;){let i={};r=asyncDone(t=>e(n,h,new Scope(m,i),o,t)),!0===r.isInstant?r.instant:(await r.p).result;let a=await executeTreeAsync(n,o,s,[new Scope(y,i)],"loop");if(a instanceof ExecReturn&&a.returned)return void t(void 0,a);if(a instanceof ExecReturn&&a.breakLoop)break;r=asyncDone(t=>e(n,f,m,o,t)),g=!0===(r=asyncDone(t=>e(n,d,m,o,t))).isInstant?r.instant:(await r.p).result}t()})().catch(t);else{for(syncDone(t=>e(n,u,y,o,t)),b.$$obj=syncDone(t=>e(n,p,y,o,t)).result,syncDone(t=>e(n,l,m,o,t)),c&&(g=syncDone(t=>e(n,d,m,o,t)).result);g;){let r={};syncDone(t=>e(n,h,new Scope(m,r),o,t));let i=executeTree(n,o,s,[new Scope(y,r)],"loop");if(i instanceof ExecReturn&&i.returned)return void t(void 0,i);if(i instanceof ExecReturn&&i.breakLoop)break;syncDone(t=>e(n,f,m,o,t)),g=syncDone(t=>e(n,d,m,o,t)).result}t()}},loopAction:(e,t,n,r,s,i,o,a,c,l)=>{if("switch"===l&&"continue"===r||!l)throw new SandboxError("Illegal "+r+" statement");t(void 0,new ExecReturn(o.ctx.auditReport,void 0,!1,"break"===r,"continue"===r))},if:(e,t,n,r,s,i,o,a,c,l)=>{if(!(s instanceof If))throw new SyntaxError("Invalid if");e(n,r,a,o,(r,i)=>{r?t(r):executeTreeWithDone(e,t,n,o,valueOrProp(i,o)?s.t:s.f,[new Scope(a)],l)})},switch:(e,t,n,r,s,i,o,a)=>{e(n,r,a,o,(r,i)=>{if(r)t(r);else if(i=valueOrProp(i,o),e===execSync){let r,c=!1;for(let l of s)if(c||(c=!l.a||i===valueOrProp(syncDone(t=>e(n,l.a,a,o,t)).result,o))){if(!l.b)continue;if(r=executeTree(n,o,l.b,[a],"switch"),r.breakLoop)break;if(r.returned)return void t(void 0,r);if(!l.a)break}t()}else(async()=>{let r,c=!1;for(let l of s){let s;if(c||(c=!l.a||i===valueOrProp(!0===(s=asyncDone(t=>e(n,l.a,a,o,t))).isInstant?s.instant:(await s.p).result,o))){if(!l.b)continue;if(r=await executeTreeAsync(n,o,l.b,[a],"switch"),r.breakLoop)break;if(r.returned)return void t(void 0,r);if(!l.a)break}}t()})().catch(t)})},try:(e,t,n,r,s,i,o,a,c,l)=>{const[p,u,f]=s;executeTreeWithDone(e,(r,s)=>{executeTreeWithDone(e,i=>{if(i)t(i);else if(r){p&&({}[p]=r),executeTreeWithDone(e,t,n,o,u,[new Scope(a)],l)}else t(void 0,s)},n,o,f,[new Scope(a,{})])},n,o,r,[new Scope(a)],l)},void:(e,t,n,r)=>{t()},new:(e,t,n,r,s,i,o)=>{if(!o.ctx.globalsWhitelist.has(r)&&!sandboxedFunctions.has(r))throw new SandboxError(`Object construction not allowed: ${r.constructor.name}`);t(void 0,new r(...s))},throw:(e,t,n,r,s)=>{t(s)},multi:(e,t,n,r)=>t(void 0,r.pop())},ops=new Map;for(let e in ops2)ops.set(e,ops2[e]);function valueOrProp(e,t){return e instanceof Prop?e.get(t):e!==optional?e:void 0}function execMany(e,t,n,r,s,i,o){t===execSync?_execManySync(e,n,r,s,i,o):_execManyAsync(e,n,r,s,i,o).catch(r)}function _execManySync(e,t,n,r,s,i){let o=[];for(let a=0;a<t.length;a++){let c;try{c=syncDone(n=>execSync(e,t[a],r,s,n,i)).result}catch(e){return void n(e)}if(c instanceof ExecReturn&&(c.returned||c.breakLoop||c.continueLoop))return void n(void 0,c);o.push(c)}n(void 0,o)}async function _execManyAsync(e,t,n,r,s,i){let o=[];for(let a=0;a<t.length;a++){let c;try{let n;c=!0===(n=asyncDone(n=>execAsync(e,t[a],r,s,n,i))).isInstant?n.instant:(await n.p).result}catch(e){return void n(e)}if(c instanceof ExecReturn&&(c.returned||c.breakLoop||c.continueLoop))return void n(void 0,c);o.push(c)}n(void 0,o)}function asyncDone(e){let t,n=!1;const r=new Promise((r,s)=>{e((e,i)=>{e?s(e):(n=!0,t=i,r({result:i}))})});return{isInstant:n,instant:t,p:r}}function syncDone(e){let t,n;if(e((e,r)=>{n=e,t=r}),n)throw n;return{result:t}}async function execAsync(e,t,n,r,s,i){let o=s;const a=new Promise(e=>{o=(t,n)=>{s(t,n),e()}});if(_execNoneRecurse(e,t,n,r,o,!0,i));else if(t instanceof Lisp){let s;try{let o;s=!0===(o=asyncDone(s=>execAsync(e,t.a,n,r,s,i))).isInstant?o.instant:(await o.p).result}catch(e){return void o(e)}let a=s;try{a=s instanceof Prop?s.get(r):s}catch(e){return void o(e)}let c,l=t.op;if("?prop"===l||"?call"===l){if(null==a)return void o(void 0,optional);l=l.slice(1)}if(a===optional){if("prop"===l||"call"===l)return void o(void 0,a);a=void 0}try{let s;c=!0===(s=asyncDone(s=>execAsync(e,t.b,n,r,s,i))).isInstant?s.instant:(await s.p).result}catch(e){return void o(e)}let p=c;try{p=c instanceof Prop?c.get(r):c}catch(e){return void o(e)}if(p===optional&&(p=void 0),ops.has(l))try{ops.get(l)(execAsync,o,e,a,p,s,r,n,c,i)}catch(e){o(e)}else o(new SyntaxError("Unknown operator: "+l))}await a}function execSync(e,t,n,r,s,i){if(_execNoneRecurse(e,t,n,r,s,!1,i));else if(t instanceof Lisp){let o;try{o=syncDone(s=>execSync(e,t.a,n,r,s,i)).result}catch(e){return void s(e)}let a=o;try{a=o instanceof Prop?o.get(r):o}catch(e){return void s(e)}let c,l=t.op;if("?prop"===l||"?call"===l){if(null==a)return void s(void 0,optional);l=l.slice(1)}if(a===optional){if("prop"===l||"call"===l)return void s(void 0,a);a=void 0}try{c=syncDone(s=>execSync(e,t.b,n,r,s,i)).result}catch(e){return void s(e)}let p=c;try{p=c instanceof Prop?c.get(r):c}catch(e){return void s(e)}if(p===optional&&(p=void 0),ops.has(l))try{ops.get(l)(execSync,s,e,a,p,o,r,n,c,i)}catch(e){s(e)}else s(new SyntaxError("Unknown operator: "+l))}}const unexecTypes=new Set(["arrowFunc","function","inlineFunction","loop","try","switch","if","?","typeof"]);function _execNoneRecurse(e,t,n,r,s,i,o){var a;const c=i?execAsync:execSync;if(!(r.ctx.options.executionQuota<=e.ticks)||"function"==typeof r.ctx.options.onExecutionQuotaReached&&r.ctx.options.onExecutionQuotaReached(e,n,r,t)){if(e.ticks++,currentTicks=e,t instanceof Prop)try{s(void 0,t.get(r))}catch(e){s(e)}else if(t===optional)s();else if(Array.isArray(t)&&t.lisp===lispArrayKey)execMany(e,c,t,s,n,r,o);else if(t instanceof Lisp)if("await"===t.op)i?(null===(a=r.ctx.prototypeWhitelist)||void 0===a?void 0:a.has(Promise.prototype))?execAsync(e,t.a,n,r,async(e,t)=>{if(e)s(e);else try{s(void 0,await valueOrProp(t,r))}catch(e){s(e)}},o).catch(s):s(new SandboxError("Async/await is not permitted")):s(new SandboxError("Illegal use of 'await', must be inside async function"));else{if(!unexecTypes.has(t.op))return!1;try{ops.get(t.op)(c,s,e,t.a,t.b,t,r,n,void 0,o)}catch(e){s(e)}}else s(void 0,t);return!0}s(new SandboxError("Execution quota exceeded"))}function executeTree(e,t,n,r=[],s){return syncDone(i=>executeTreeWithDone(execSync,i,e,t,n,r,s)).result}async function executeTreeAsync(e,t,n,r=[],s){let i;return!0===(i=asyncDone(i=>executeTreeWithDone(execAsync,i,e,t,n,r,s))).isInstant?i.instant:(await i.p).result}function executeTreeWithDone(e,t,n,r,s,i=[],o){if(!s)return void t();if(!(s instanceof Array))throw new SyntaxError("Bad execution tree");let a,c=r.ctx.globalScope;for(;a=i.shift();)"object"==typeof a&&(c=a instanceof Scope?a:new Scope(c,a,a instanceof LocalScope?void 0:null));r.ctx.options.audit&&!r.ctx.auditReport&&(r.ctx.auditReport={globalsAccess:new Set,prototypeAccess:{}}),e===execSync?_executeWithDoneSync(t,n,r,s,c,o):_executeWithDoneAsync(t,n,r,s,c,o).catch(t)}function _executeWithDoneSync(e,t,n,r,s,i){if(!(r instanceof Array))throw new SyntaxError("Bad execution tree");let o=0;for(o=0;o<r.length;o++){let a,c;const l=r[o];try{execSync(t,l,s,n,(e,t)=>{c=e,a=t},i)}catch(e){c=e}if(c)return void e(c);if(a instanceof ExecReturn)return void e(void 0,a);if(l instanceof Lisp&&"return"===l.op)return void e(void 0,new ExecReturn(n.ctx.auditReport,a,!0))}e(void 0,new ExecReturn(n.ctx.auditReport,void 0,!1))}async function _executeWithDoneAsync(e,t,n,r,s,i){if(!(r instanceof Array))throw new SyntaxError("Bad execution tree");let o=0;for(o=0;o<r.length;o++){let a,c;const l=r[o];try{await execAsync(t,l,s,n,(e,t)=>{c=e,a=t},i)}catch(e){c=e}if(c)return void e(c);if(a instanceof ExecReturn)return void e(void 0,a);if(l instanceof Lisp&&"return"===l.op)return void e(void 0,new ExecReturn(n.ctx.auditReport,a,!0))}e(void 0,new ExecReturn(n.ctx.auditReport,void 0,!1))}class SandboxGlobal{constructor(e){if(e===globalThis)return globalThis;for(let t in e)this[t]=e[t]}}class ExecContext{constructor(e,t,n,r,s,i,o,a,c,l){this.ctx=e,this.constants=t,this.tree=n,this.getSubscriptions=r,this.setSubscriptions=s,this.changeSubscriptions=i,this.setSubscriptionsGlobal=o,this.changeSubscriptionsGlobal=a,this.evals=c,this.registerSandboxFunction=l}}function subscribeSet(e,t,n,r){const s=r.setSubscriptions.get(e)||new Map;r.setSubscriptions.set(e,s);const i=s.get(t)||new Set;let o;return s.set(t,i),i.add(n),e&&e[t]&&"object"==typeof e[t]&&(o=r.changeSubscriptions.get(e[t])||new Set,o.add(n),r.changeSubscriptions.set(e[t],o)),{unsubscribe:()=>{i.delete(n),null==o||o.delete(n)}}}class Sandbox{constructor(e){this.setSubscriptions=new WeakMap,this.changeSubscriptions=new WeakMap,this.sandboxFunctions=new WeakMap,e=Object.assign({audit:!1,forbidFunctionCalls:!1,forbidFunctionCreation:!1,globals:Sandbox.SAFE_GLOBALS,prototypeWhitelist:Sandbox.SAFE_PROTOTYPES,prototypeReplacements:new Map},e||{});const t=new SandboxGlobal(e.globals);this.context={sandbox:this,globalsWhitelist:new Set(Object.values(e.globals)),prototypeWhitelist:new Map([...e.prototypeWhitelist].map(e=>[e[0].prototype,e[1]])),options:e,globalScope:new Scope(null,e.globals,t),sandboxGlobal:t},this.context.prototypeWhitelist.set(Object.getPrototypeOf([][Symbol.iterator]()),new Set)}static get SAFE_GLOBALS(){return{Function:Function,console:{debug:console.debug,error:console.error,info:console.info,log:console.log,table:console.table,warn:console.warn},isFinite:isFinite,isNaN:isNaN,parseFloat:parseFloat,parseInt:parseInt,decodeURI:decodeURI,decodeURIComponent:decodeURIComponent,encodeURI:encodeURI,encodeURIComponent:encodeURIComponent,escape:escape,unescape:unescape,Boolean:Boolean,Number:Number,BigInt:BigInt,String:String,Object:Object,Array:Array,Symbol:Symbol,Error:Error,EvalError:EvalError,RangeError:RangeError,ReferenceError:ReferenceError,SyntaxError:SyntaxError,TypeError:TypeError,URIError:URIError,Int8Array:Int8Array,Uint8Array:Uint8Array,Uint8ClampedArray:Uint8ClampedArray,Int16Array:Int16Array,Uint16Array:Uint16Array,Int32Array:Int32Array,Uint32Array:Uint32Array,Float32Array:Float32Array,Float64Array:Float64Array,Map:Map,Set:Set,WeakMap:WeakMap,WeakSet:WeakSet,Promise:Promise,Intl:Intl,JSON:JSON,Math:Math,Date:Date,RegExp:RegExp}}static get SAFE_PROTOTYPES(){let e=[SandboxGlobal,Function,Boolean,Number,BigInt,String,Date,Error,Array,Int8Array,Uint8Array,Uint8ClampedArray,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array,Map,Set,WeakMap,WeakSet,Promise,Symbol,Date,RegExp],t=new Map;return e.forEach(e=>{t.set(e,new Set)}),t.set(Object,new Set(["entries","fromEntries","getOwnPropertyNames","is","keys","hasOwnProperty","isPrototypeOf","propertyIsEnumerable","toLocaleString","toString","valueOf","values"])),t}subscribeGet(e,t){return t.getSubscriptions.add(e),{unsubscribe:()=>t.getSubscriptions.delete(e)}}subscribeSet(e,t,n,r){return subscribeSet(e,t,n,r)}subscribeSetGlobal(e,t,n){return subscribeSet(e,t,n,this)}static audit(e,t=[]){const n={};for(let e of Object.getOwnPropertyNames(globalThis))n[e]=globalThis[e];const r=new Sandbox({globals:n,audit:!0});return r.executeTree(r.createContext(r.context,parse(e)),t)}static parse(e){return parse(e)}createContext(context,executionTree){const evals=new Map,execContext=new ExecContext(context,executionTree.constants,executionTree.tree,new Set,new WeakMap,new WeakMap,this.setSubscriptions,this.changeSubscriptions,evals,e=>this.sandboxFunctions.set(e,execContext)),func=sandboxFunction(execContext);return evals.set(Function,func),evals.set(eval,sandboxedEval(func)),evals.set(setTimeout,sandboxedSetTimeout(func)),evals.set(setInterval,sandboxedSetInterval(func)),execContext}getContext(e){return this.sandboxFunctions.get(e)}executeTree(e,t=[]){return executeTree({ticks:BigInt(0)},e,e.tree,t)}executeTreeAsync(e,t=[]){return executeTreeAsync({ticks:BigInt(0)},e,e.tree,t)}compile(e,t=!1){const n=parse(e,t);return(...e)=>{const t=this.createContext(this.context,n);return{context:t,run:()=>this.executeTree(t,[...e]).result}}}compileAsync(e,t=!1){const n=parse(e,t);return(...e)=>{const t=this.createContext(this.context,n);return{context:t,run:()=>this.executeTreeAsync(t,[...e]).then(e=>e.result)}}}compileExpression(e,t=!1){const n=parse(e,t,!0);return(...e)=>{const t=this.createContext(this.context,n);return{context:t,run:()=>this.executeTree(t,[...e]).result}}}compileExpressionAsync(e,t=!1){const n=parse(e,t,!0);return(...e)=>{const t=this.createContext(this.context,n);return{context:t,run:()=>this.executeTreeAsync(t,[...e]).then(e=>e.result)}}}}const regHrefJS=/^\s*javascript\s*:/i,regValidSrc=/^((https?:)?\/\/|\.?\/|#)/,regSystemAtt=/^(:|@|\$|s-)/,regReservedSystemAtt=/^skope-/,defaultHTMLWhiteList=[HTMLBRElement,HTMLBodyElement,HTMLDListElement,HTMLDataElement,HTMLDataListElement,HTMLDivElement,HTMLFieldSetElement,HTMLFormElement,HTMLHRElement,HTMLHeadingElement,HTMLLIElement,HTMLLegendElement,HTMLMapElement,HTMLMetaElement,HTMLMeterElement,HTMLModElement,HTMLOListElement,HTMLOutputElement,HTMLParagraphElement,HTMLPreElement,HTMLProgressElement,HTMLQuoteElement,HTMLSpanElement,HTMLTableCaptionElement,HTMLTableCellElement,HTMLTableColElement,HTMLTableElement,HTMLTableSectionElement,HTMLTableRowElement,HTMLTimeElement,HTMLTitleElement,HTMLUListElement,HTMLUnknownElement,HTMLTemplateElement,HTMLCanvasElement,HTMLElement],globalAllowedAtttributes=new Set(["id","class","style","alt","role","aria-label","aria-labelledby","aria-hidden","tabindex","title","dir","lang","height","width","slot"]);function sanitizeType(e,t,n,r){const s=new Set(n);for(const n of t)e.types.set(n,{attributes:s,element:r})}const reservedAtrributes=new WeakMap;class HTMLSanitizer{constructor(){this.types=new Map,this.srcAttributes=new Set(["action","href","xlink:href","formaction","manifest","poster","src","from"]),this.allowedInputs=new Set(["button","checkbox","color","date","datetime-local","email","file","month","number","password","radio","range","reset","tel","text","time","url","week"]),sanitizeType(this,defaultHTMLWhiteList,[],()=>!0),sanitizeType(this,[HTMLAnchorElement,HTMLAreaElement],["href","xlink:href","rel","shape","coords"],e=>!0),sanitizeType(this,[HTMLButtonElement],["type","value"],e=>("reset"!==e.type&&"button"!==e.type&&(e.type="button"),!0)),sanitizeType(this,[HTMLInputElement,HTMLSelectElement,HTMLOptGroupElement,HTMLOptionElement,HTMLLabelElement,HTMLTextAreaElement],["value","type","checked","selected","name","for","max","min","placeholder","readonly","size","multiple","step","autocomplete","cols","rows","maxlength","disabled","required","accept","list"],e=>!0),sanitizeType(this,[HTMLScriptElement],["type"],(e,t)=>{if(!e.type||"text/javascript"===e.type){e.type="skopejs";const t=e.innerHTML;e.innerHTML="",setTimeout(()=>{e.innerHTML=t})}return!t&&"skopejs"===e.type}),sanitizeType(this,[HTMLIFrameElement],[],e=>(e.getAttribute("skope-iframe-content")||this.setAttributeForced(e,"skope-iframe-content",e.innerHTML),e.innerHTML="",!e.src&&!e.srcdoc)),sanitizeType(this,[HTMLStyleElement],[],(e,t)=>!t),sanitizeType(this,[HTMLPictureElement,HTMLImageElement,HTMLAudioElement,HTMLTrackElement,HTMLVideoElement,HTMLSourceElement],["src","srcset","sizes","poster","autoplay","contorls","muted","loop","volume","loading"],e=>!0)}santizeAttribute(e,t,n,r=!1,s=!1){const i=this.types.get(e.constructor);if(!i)return!1;if(t=t.toLowerCase(),this.isAttributeForced(e,t)){if(s)return!1}else if(t.match(regSystemAtt)||"skope"===t){if(!r)return!1}else{if(/^on[a-z]+$/.test(t))return r&&e.setAttribute(`@${t.slice(2)}`,n),!1;if(i.attributes.has(t)&&this.srcAttributes.has(t)&&"javascript:void(0)"!==n){const s=n.match(regHrefJS);if(s){if(!r||"href"!==t&&"xlink:href"!==t)return!1;e.hasAttribute("@click")||e.setAttribute("@click",n.substring(s[0].length))}else if(!n.match(regValidSrc))return!1}else{if(!r&&e instanceof HTMLScriptElement)return!1;if(!i.attributes.has(t)&&!globalAllowedAtttributes.has(t))return!1;if(e instanceof HTMLInputElement&&"type"===t)return this.allowedInputs.has(n);if(e instanceof HTMLButtonElement&&"type"===t)return"reset"===n||"button"===n}}return!0}sanitizeHTML(e,t=!1){if(!(e instanceof DocumentFragment)){const n=this.types.get(e.constructor);if(!n||!n.element(e,t))return void e.remove();for(const n of[...e.attributes]){const r=n.nodeValue,s=n.nodeName;(!this.santizeAttribute(e,s,r,!t)||t&&["id","style"].includes(s))&&e.removeAttribute(n.nodeName)}}if(e.children){const n=e instanceof HTMLTemplateElement?e.content.children:e.children;for(const e of[...n])this.sanitizeHTML(e,t)}}isAttributeForced(e,t){return reservedAtrributes.get(e)?.has(t)||regReservedSystemAtt.test(t)&&e.hasAttribute(t)}setAttributeForced(e,t,n){let r=reservedAtrributes.get(e);r||(r=new Set,reservedAtrributes.set(e,r)),r.add(t),e.setAttribute(t,n)}observeAttribute(e,t,n,r,s=!1){const i=new Set,o=`[${t}]:not([${t}] [${t}])`,a=e=>{if(r)for(const t of e.children)this.sanitizeHTML(t,r);else this.sanitizeHTML(e,r)},c=(e,t)=>new Promise(n=>{a(e);const r=new MutationObserver(e=>{for(const n of e)for(const e of n.addedNodes)e instanceof Element&&this.sanitizeHTML(e,t)});document.addEventListener("readystatechange",()=>{"loading"!==document.readyState&&setTimeout(()=>{s(),n(e)})}),r.observe(e,{childList:!0,subtree:!0});const s=()=>{r.disconnect(),i.delete(s)};i.add(s)}),l=e=>e.matches(o);let p=!1;if("loading"===document.readyState||s){p=!0;const t=new WeakSet,u=n=>!(!n||n===e)&&(!!t.has(n)||u(n.parentElement)),f=new MutationObserver(e=>{for(const s of e)for(const e of s.addedNodes)if(e instanceof Element)if(p)if(!u(e)&&l(e))t.add(e),c(e,r).then(e=>{n(e)});else for(const s of e.querySelectorAll(o))u(s)||(t.add(s),c(s,r).then(e=>{n(e)}));else if(l(e))a(e),n(e);else for(const t of e.querySelectorAll(o))a(e),n(t)});s||document.addEventListener("readystatechange",()=>{"loading"!==document.readyState&&setTimeout(()=>{p=!1,d()})}),f.observe(e,{childList:!0,subtree:!0});const d=()=>{f.disconnect(),i.delete(d)};i.add(d)}if(l(e))a(e),n(e);else for(const t of e.querySelectorAll(o))a(t),n(t);return{cancel(){for(const e of i)e()}}}}const regVarName=/^\s*([a-zA-Z$_][a-zA-Z$_\d]*)\s*$/,regKeyValName=/^\s*\(([a-zA-Z$_][a-zA-Z$_\d]*)\s*,\s*([a-zA-Z$_][a-zA-Z$_\d]*)\s*\)$/;function isObject(e){return null!==e&&"object"==typeof e}function isIterable(e){return e&&"object"==typeof e&&Symbol.iterator in e}function createVarSubs(e,t){const n={subscribeGet:n=>e.sandbox.subscribeGet(n,t),subscribeSet:(n,r,s)=>e.sandbox.subscribeSet(n,r,s,t)};return n}function unsubNested(e){if(!e)return;if("function"==typeof e)return void e();const t=e.slice();e.length=0,t.forEach(e=>{Array.isArray(e)?unsubNested(e):e()})}function createErrorCb(e){return t=>createError(t?.message,e)}function createError(e,t){const n=new Error(e);return n.element=t,errorCb(n,t),n}let errorCb=(e,t)=>{console.error(e,t)};function getRootScope(e,t){for(let n=t.length-1;n>=0;n--)if(t[n]instanceof e.RootScope)return t[n]}function getRootElement(e,t){return getRootScope(e,t)?.$el.get(0)}function getScope(e,t,n,r={},s){let i=e.getStore(t,"scope");return s&&(i=e.getStore(t,"rootScope")),i||(e.getStore(t,"currentSubs",n),s?(i=e.getStore(t,"rootScope",new e.RootScope(t)),e.getStore(t,"scope",i)):i=e.getStore(t,"scope",new e.ElementScope(t)),n.push(()=>{i.$el=null,e.deleteStore(t,"currentSubs"),e.deleteStore(t,"scope"),e.deleteStore(t,"rootScope")})),Object.assign(i,r),i}function getScopes(e,t,n=[],r){if(!t)return[];const s=void 0===r?e.getStore(t,"scope"):getScope(e,t,n,r),i=e.getStore(t,"scopes")||[];return i.length?[...i,s]:(s&&i.push(s),[...t.hasAttribute("s-detached")?[]:getScopes(e,t.parentElement),...i])}function pushScope(e,t,n,r,s){const i=getScope(e,n,r,s);return i===t[t.length-1]?[...t]:[...t,i]}function watchRun(e,t,n,r){try{const t=e.exec(getRootElement(e,n),`return ${r}`,n);return e.varSubsStore.set(t.run,createVarSubs(e,t.context)),t.run}catch(n){createError(n.message,t);const r=()=>{};return e.varSubsStore.set(r,{subscribeGet:()=>({unsubscribe(){}}),subscribeSet:()=>({unsubscribe(){}})}),r}}function watch(e,t,n,r,s){const i=new Map,o=[];let a,c=e.varSubsStore.get(n);if(!c){const r=e.sandbox.getContext(n);if(!r)return createError("Non-sandbox watch callback",t),o;c=createVarSubs(e,r)}let l,p=!1,u=Date.now(),f=0;const d=()=>{const h=new WeakMap;if(unsubNested(o),Date.now()-u>4e3)f=0,u=Date.now();else if(f++>200)return void createError("Too many digests",t);const g=c.subscribeGet((e,t)=>{if(void 0===e)return;const n=i.get(e)||new Set;n.add(t),i.set(e,n)});let y;try{y=n()}catch(e){return g.unsubscribe(),void createError(e?.message,t)}g.unsubscribe();for(const e of i){const t=e[0];for(const n of e[1])o.push(c.subscribeSet(t,n,()=>{let e=h.get(t);e||(e={[n]:0},h.set(t,e)),e[n]++}).unsubscribe)}for(const t of i){const n=t[0];for(const r of t[1])o.push(e.sandbox.subscribeSetGlobal(n,r,t=>{const s=h.get(n);s?.[r]?s[r]--:p||(p=!0,e.call(()=>{p=!1,d()}))}).unsubscribe)}i.clear();const b=Promise.resolve(s?y:void 0);l=b,b.then(e=>{if(l===b&&(e=s?e:y)!==a){const n=a;a=e;try{r(e,n)}catch(e){createError(e?.message,t)}}},s)};return d(),o}function eventDirective(e,t,n,r,s,i){const o=n.nodeName.split("$"),a=o[0].slice(1).split("."),c=/^debounce(\((\d+)\))?$/.exec(a[1]||""),l=/^throttle(\((\d+)\))?$/.exec(a[1]||""),p=/^queue(\((\d+)\))?$/.exec(a[1]||"");if(a[1]&&!(c||l||p||"once"===a[1]))return void createError(`Invalid event directive: ${a[1]}`,n);const u=o[1]?.replace(/-([\w$])/g,(e,t)=>t.toUpperCase());!u||regVarName.test(u)?s(s=>{let o;u&&e.exec(getRootElement(e,s),`if (typeof ${u} === 'undefined') var ${u}`,s).run();const f=i=>{o=e.execAsync(getRootElement(e,s),n.nodeValue,pushScope(e,s,t,r,{$event:i})).run(),o.catch(()=>{}),u&&e.exec(getRootElement(e,s),`${u} = trans`,pushScope(e,s,t,r,{trans:o})).run()};let d=f;if(c){let e=null;d=t=>{clearTimeout(e),e=setTimeout(()=>{e=null,f(t)},Number(c[2]||250))}}if(l)if(void 0===l[2]){let e=!1;d=t=>{!e&&o||(e=!1,f(t),o.then(()=>e=!0,()=>e=!0))}}else{let e,t=null;d=n=>{e=n,null===t&&(t=setTimeout(()=>{t=null,f(e)},Number(l[2])))}}if(p){let e=0,t=Promise.resolve();d=n=>{(!p[2]||Number(p[2])>e)&&(e++,t=t.then(()=>(f(n),o)).catch(()=>{}).then(()=>e--))}}"once"===a[1]?r.push(i.one(t,a[0],d)):r.push(i.on(t,a[0],d))}):createError("Invalid variable name in attribute",n)}function ifDirective(e,t,n,r,s,i){const o=document.createComment("s-if");let a;const c=t.getAttribute("s-if");t.before(o),t.remove(),e.deleteStore(t,"currentSubs"),s(s=>{e.getStore(o,"currentSubs",r);const l=[];r.push(l);try{r.push(e.watch(n,watchRun(e,n,s,c),(n,r)=>{if(n){if(!a){a=t.cloneNode(!0),a.removeAttribute("s-if");const n=e.processHTML(e,a,l,i);o.after(n.elem),n.run(pushScope(e,s,a,l))}}else a&&(a.remove(),a=void 0,unsubNested(l))},e=>{a&&(a.remove(),a=void 0,unsubNested(l))}))}catch(e){createError(e.message,n)}})}function forDirective(e,t,n,r,s){const i=document.createComment("s-for");t.after(i),t.remove(),e.deleteStore(t,"currentSubs");const o=new Set,a=t.getAttribute("s-for").split(" in ");if(a.length<2)return void createError("In valid s-for directive",n);const c=a.slice(1).join(" in "),l=a[0];let p,u,f;const d=l.match(regVarName);if(d)[f,u]=d;else if([f,p,u]=l.match(regKeyValName),!f)return void createError("In valid s-for directive",n);s(s=>{const a=e.wrapElem(i.parentElement).delegate();r.push(a.off);const l=[];r.push(l),r.push(e.watch(n,watchRun(e,n,s,c),n=>{unsubNested(l),o.forEach(e=>{e.remove()}),o.clear();const r=[],c=(n,c)=>{const f=[];l.push(f);const d={$index:c};p&&(d[p]=c),u&&(d[u]=n);const h=t.cloneNode(!0);h.removeAttribute("s-for");const g=e.processHTML(e,h,f,a);i.before(g.elem),o.add(h),r.push(()=>g.run(pushScope(e,s,h,f,d)))};let f=-1;if(isIterable(n))for(const e of n)f++,c(e,f);else if(isObject(n))for(const e in n)c(n[e],e);r.forEach(e=>e())},()=>{unsubNested(l),o.forEach(e=>{e.remove()}),o.clear()}))})}function variableDirective(e,t,n,r,s,i,o){const a=n.nodeName.substring(1).replace(/-([\w$])/g,(e,t)=>t.toUpperCase());return a.match(regVarName)?(o.elementScopeAdded||(o.elementScopeAdded=!0,s(n=>pushScope(e,n,t,r))),s(t=>{e.execAsync(getRootElement(e,t),`let ${a} = ${n.nodeValue}`,t).run().catch(createErrorCb(n))}),s):(createError("Invalid variable name in attribute",n),s)}function detachedDirective(e,t,n,r,s,i,o){s(n=>{const s=[getScope(e,t,r,{},!0)];return o.elementScopeAdded&&(s[0].$templates={...n[n.length-1].$templates||{}},delete n[n.length-1].$templates,s.push(n[n.length-1])),s})}function attributeDirective(e,t,n,r,s,i){const o=n.nodeName.slice(1),a=o.split(".");s(s=>{const i=e.wrapElem(t);r.push(e.watch(n,watchRun(e,n,s,n.nodeValue),(e,n)=>{"object"==typeof e&&["style","class"].includes(o)?Object.entries(e).forEach(e=>Promise.resolve(e[1]).then(n=>{"class"===o?i.toggleClass(e[0],!!n):(t instanceof HTMLElement||t instanceof SVGElement)&&(t.style[e[0]]=n)},()=>{"class"===o&&i.toggleClass(e[0],!1)})):2===a.length&&["style","class"].includes(a[0])?"class"===a[0]?i.toggleClass(a[1],!!e):(t instanceof HTMLElement||t instanceof SVGElement)&&(t.style[a[1]]=e):i.attr(o,`${e}`)},()=>{}))})}function styleElement(e,t){const n=()=>{const n=t.parentElement;if(!n)return;const r=n.getAttribute("skope-style")||++e.styleIds;e.sanitizer.setAttributeForced(n,"skope-style",`${r}`);let s=t.sheet.cssRules.length-1;for(const e of[...t.sheet.cssRules].reverse())e instanceof CSSStyleRule||e instanceof CSSKeyframesRule||t.sheet.deleteRule(s),s--;s=0;for(const e of[...t.sheet.cssRules]){if(e instanceof CSSStyleRule){const{cssText:n}=e.style;t.sheet.deleteRule(s),t.sheet.insertRule(`[skope-style="${r}"] :is(${e.selectorText}) { ${n} }`,s)}s++}};t.sheet&&t.parentElement?n():t.addEventListener("load",n)}function scriptElement(e,t,n){"skopejs"===t.type?n(n=>{try{e.exec(getRootElement(e,n),t.innerHTML,n).run()}catch(e){createError(e?.message,t)}}):t.remove()}function iframetElement(e,t,n){n(()=>{const n=()=>{e.wrapElem(t).html(t.getAttribute("skope-iframe-content")),t.removeAttribute("skope-iframe-content")};"complete"!==t.contentDocument.readyState?t.addEventListener("load",n):n()})}function runDirective(e,t,n){const r=e.directives[t.directive];return r?r(t,n):(createError("Unknown directive",t.att),[])}function walkerInstance(){const e=[];return{ready:t=>e.push(t),run:function(t){e.reduce((e,t)=>t(e)||e,t),e.length=0}}}const closings={"(":")","{":"}","[":"]"},quotes=["'",'"',"`"];function walkText(e,t=null){const n=[];let r=null,s=null,i=!1,o=!!t,a=0,c=0;for(;c<e.length;c++){const l=e[c],p=e[c+1];if(o)if(r)if(i||r!==l){if("\\"===l)i=!i;else if(!i&&"`"===r&&"$"===l&&"{"===p){c+=walkText(e.substring(c+2),"}")[0].length+2}}else r=null;else if(quotes.includes(l))r=l;else if(s)closings[s]===l&&(s=null);else if(closings[l])s=l;else{if(l===t)return n.push(e.substring(a,c)),n;"}"===l&&"}"===p&&(n.push(e.substring(a,c+2)),o=!1,c+=1,a=c+1)}else"{"===l&&"{"===p&&(o=!0,a!==c&&n.push(e.substring(a,c)),a=c,c+=1)}return a!==c&&a<e.length&&n.push(e.substring(a,c)),n.filter(Boolean)}function walkTree(e,t,n,r,s,i){const o=[];n.push(o);const a=()=>{const n=[];for(const i of[...t.childNodes])if(i instanceof Element){const t=walkerInstance();n.push(t.run),walkTree(e,i,o,t.ready,s,!1)}else if(3===i.nodeType){const n=walkText(i.textContent),s=[];let a=!1;for(const c of n)if(c.startsWith("{{")&&c.endsWith("}}")){e.getStore(i,"currentSubs",o),a=!0;const n=document.createTextNode("");r(r=>{o.push(e.watch(t,watchRun(e,i,r,c.slice(2,-2)),(e,t)=>{n.textContent=`${e}`},e=>{n.textContent=""}))}),s.push(n)}else s.push(document.createTextNode(c));if(a){for(const e of s)i.before(e);i.remove()}}r(e=>{for(const t of n)t(e);n.length=0})};if(i)a();else{if(t instanceof Element){if(t instanceof HTMLTemplateElement)return;if(t instanceof HTMLStyleElement)return void styleElement(e,t);if(t instanceof HTMLScriptElement)return void scriptElement(e,t,r);if(e.getStore(t,"currentSubs",n),t.removeAttribute("s-cloak"),t.hasAttribute("s-if"))return void ifDirective(e,t,t.getAttributeNode("s-if"),o,r,s);if(t.hasAttribute("s-for"))return void forDirective(e,t,t.getAttributeNode("s-for"),o,r);if(t.hasAttribute("s-component"))return void r(n=>{try{o.push(runDirective(e,{element:t,att:t.getAttributeNode("s-component"),directive:"component",js:"",original:t.outerHTML,subs:o,delegate:s},n))}catch(e){createError(e.message,t)}});const i={elementScopeAdded:!1};for(const n of t.attributes)n.nodeName.startsWith("$")&&variableDirective(e,t,n,o,r,s,i);t.hasAttribute("s-detached")&&detachedDirective(e,t,t.getAttributeNode("s-detached"),o,r,s,i),t instanceof HTMLIFrameElement&&t.hasAttribute("skope-iframe-content")&&iframetElement(e,t,r);for(const n of t.attributes)if(n.nodeName.startsWith(":"))attributeDirective(e,t,n,o,r);else if(n.nodeName.startsWith("@"))eventDirective(e,t,n,o,r,s);else if(n.nodeName.startsWith("s-")&&"s-detached"!==n.nodeName&&"s-static"!==n.nodeName)try{r(r=>{o.push(runDirective(e,{element:t,att:n,directive:n.nodeName.slice(2),js:n.nodeValue,original:t.outerHTML,subs:o,delegate:s},pushScope(e,r,t,o)))})}catch(e){createError(e.message,n)}}t instanceof Element&&t.hasAttribute("s-static")||a()}}const elementStorage=new WeakMap;function ownerDoc(e){return e.get(0)?.ownerDocument}function createClass(e){const t=new WeakMap;function n(e){return t.get(e)||[]}const r={on(e,t,n){const r=o(e,e.ownerDocument);return r.on(t,n),()=>r.off(t,n)},one(e,t,n){const r=o(e,e.ownerDocument);return r.one(t,n),()=>r.off(t,n)},off(){}};class s{constructor(e,...n){t.set(this,new Array(e,...n))}get length(){return n(this).length}get $elements(){return[...n(this)]}[Symbol.iterator](){return this.$elements[Symbol.iterator]()}forEach(e){this.$elements.forEach(e)}map(e){return this.$elements.map(e)}filter(e){return c(this,e)}some(e){return this.$elements.some(e)}every(e){return this.$elements.every(e)}slice(e,t){return new s(...n(this).slice(e,t))}sort(e){if(e){const n=this.$elements.sort(e);t.set(this,n)}else n(this).sort((e,t)=>e===t?0:Math.floor(e.compareDocumentPosition(t)/2)?1:-1);return this}reverse(){return n(this).reverse(),this}unique(){return f(this.toSet())}toArray(){return this.$elements}toSet(){const e=new Set;return this.forEach(t=>e.add(t)),e}is(e){if("string"==typeof e)return this.some(t=>t.matches(e));const t=(e instanceof s?e:o(e,this)).toSet();return this.some(e=>t.has(e))}not(e){if("string"==typeof e)return c(this,(t,n)=>!t.matches(e));const t=(e instanceof s?e:o(e,this)).toSet();return c(this,(e,n)=>!t.has(e))}has(e){if("string"==typeof e){const t=new Set;return c(this,r=>{if(t.has(r))return!0;let s=[...r.querySelectorAll(`:scope ${e}`)];return s=s.concat(n(function(e,t){return f(p(e,"parentNode",t,!0)).sort().reverse()}(s))),s.forEach(e=>t.add(e)),s.length})}const t=e instanceof s?e:o(e,this);return c(this,(e,n)=>t.some(t=>e!==t&&a(e,t)))}find(e){if("function"==typeof e){const t=e;return new s(n(this).find((e,n,r)=>t(e,n)))}return o(e,this)}on(e,t,n){const r="function"==typeof t?n:t;return u(e,"function"==typeof t?t:void 0,(e,t)=>{const n=e=>t(i(e));this.forEach(s=>{const i=d(s,"events",new Map),o=i.get(e)||new Map;o.set(t,n),i.set(e,o),s.addEventListener(e,n,r)})}),this}off(e,t){return e?u(e,t||!1,(e,t)=>{this.forEach(n=>{const r=d(n,"events",new Map).get(e)||new Map;if(t){const s=r.get(t);if(!s)return;n.removeEventListener(e,s),r.delete(t)}else r.forEach(t=>{n.removeEventListener(e,t)}),r.clear()})}):this.forEach(e=>{const t=d(e,"events",new Map);t.forEach((t,n)=>{t.forEach(t=>{e.removeEventListener(n,t)}),t.clear()}),t.clear()}),this}trigger(e,t=void 0,n=!0,r=!0){const s=new CustomEvent(e,{bubbles:n,cancelable:r,detail:t});return this.forEach(e=>{e.dispatchEvent(s)}),this}one(e,t,n){const r="function"==typeof t?n:t;return u(e,"function"==typeof t?t:void 0,(e,t)=>{this.forEach(n=>{const s=o(n,n.ownerDocument),i=n=>{s.off(e,i),t(n)};s.on(e,i,r)})}),this}delegate(){const e=n(this)[0];let t=d(e,"delegate");if(t)return t;const s=new WeakMap,o=new Map,a=new Set,c=new Map;return e?(t={on(t,n,r){const a=s.get(t)||new Map;s.set(t,a);const l=[];return u(n,r||!1,(t,n)=>{let r=a.get(t),p=o.get(t);if(p||(p=new Set,o.set(t,p)),r||(r=new Set,a.set(t,r),p.add(r)),r.add(n),!c.has(t)){const n=n=>{let r=n.target;const o=[];do{let e;(e=s.get(r)?.get(t))&&o.push(e)}while(r!==e&&(r=r.parentElement));const a=i(n);o.forEach((e,t)=>{a.stoppedPropagation||e.forEach(e=>{a.stoppedImmediatePropagation||e(a)})})},r=()=>{o.delete(t),c.delete(t),e.removeEventListener(t,n,!0)};e.addEventListener(t,n,!0),c.set(t,r)}l.push(()=>{r.delete(n),0===r.size&&(a.delete(t),p.delete(r),0===p.size&&c.get(t)?.())})}),()=>{l.forEach(e=>e())}},one(e,t,n){const r=i=>{a.has(r)&&(a.delete(n),s.get(e)?.get(t)?.delete(n),0===s.get(e)?.get(t).size&&s.get(e)?.delete(t)),n(i)};return a.add(r),this.on(e,s,r)},off(){o.forEach(e=>e.forEach(e=>e.clear())),c.forEach(e=>e()),c.clear(),a.clear()}},d(e,"delegate",t),t):r}click(e,t){return void 0===e?this.trigger("click",1):(this.on("click",e,t).not("a[href], button, input, select, textarea").once("eqAllyClick").addClass("eq-ally-click").on("keydown",e=>{"enter"===e.key.toLowerCase()&&e.currentTarget instanceof HTMLElement&&"true"!==e.currentTarget.getAttribute("aria-disabled")&&e.currentTarget.click()}).attr({tabindex:0,role:"button"}),this)}hover(e,t){return this.on("mouseenter",e).on("mouseleave",t)}attr(t,r){return u(t,r,(t,n)=>{this.forEach(r=>{if(!e().santizeAttribute(r,t,`${n}`))throw new Error(`Illegal attribute [${t}] value for <${r.nodeName.toLowerCase()}>: ${n}`);r.setAttribute(t,`${n}`)})})?this:n(this)[0]&&"string"==typeof t?n(this)[0].getAttribute(t):null}removeAttr(t){return this.forEach(n=>{if(!e().santizeAttribute(n,t,"",!1,!0))throw new Error(`Not allowed to remove attribute [${t}] value for <${n.nodeName.toLowerCase()}>`);n.removeAttribute(t)}),this}val(e){if(void 0!==e)return this.forEach(t=>{if(t instanceof HTMLInputElement)"checkbox"===t.type||"radio"===t.type?e===t.value||!0===e?t.setAttribute("checked","checked"):t.removeAttribute("checked"):"file"===t.type&&e||(t.value=`${e}`);else if(t instanceof HTMLSelectElement){const n=e instanceof Array?e:[e];[...t.options].forEach(e=>{e.selected=n.includes(e.value)})}else t.value=`${e}`;t instanceof HTMLTextAreaElement||t instanceof HTMLInputElement&&(!t.type||"text"===t.type||"tel"===t.type)?new s(t).trigger("input"):new s(t).trigger("change")}),e;const t=n(this)[0];if(t){if(t instanceof HTMLInputElement)return"checkbox"===t.type?t.checked:"radio"===t.type?t.checked?t.value:void 0:"number"===t.type||"range"===t.type?+t.value:"file"===t.type?t.files:t.value;if(t instanceof HTMLSelectElement){const e=[...t.options].filter(e=>e.selected).map(e=>e.value);if(t.multiple){const n=d(t,"multiSelect",[]);return n.length=0,n.push(...e),n}return e.pop()}return t?.value}}vals(e){const t=o([this.filter("input[name], select[name], textarea[name]"),this.find("input[name], select[name], textarea[name]")],this),n={};return void 0===e?t.forEach(e=>{e.name&&(e instanceof HTMLInputElement&&"radio"===e.type?(n[e.name]=n[e.name],e.checked&&(n[e.name]=e.value)):n[e.name]=o(e,e.ownerDocument).val())}):t.forEach(t=>{void 0!==e[t.name]&&(n[t.name]=e[t.name],t instanceof HTMLInputElement&&"radio"===t.type?t.checked=e[t.name]===t.value:o(t,t.ownerDocument).val(e[t.name]))}),n}text(e){return l(this,"textContent",e)}scrollTop(e){return l(this,"scrollTop",e)}scrollLeft(e){return l(this,"scrollLeft",e)}label(e){if("string"==typeof e)return this.attr("aria-label",e);if(!this.get(0))return null;const t=e=>e&&e.length&&e;return t(this.attr("aria-label"))||t(t(this.attr("aria-labelledby"))&&o(`#${this.attr("aria-labelledby")}`,this).label())||t(t(this.attr("id"))&&o(`label[for="${this.attr("id")}"]`,this).label())||t(this.attr("title"))||t(this.attr("placeholder"))||t(this.attr("alt"))||(t(this.text())||"").trim()}data(e,t){if(u(e,t,(e,t)=>{this.forEach(n=>{d(n,"data",{})[e]=t})}))return this;if(!n(this)[0])return null;const r=d(n(this)[0],"data")||{};return void 0===e?r:"string"==typeof e?r[e]:r}removeData(e){return this.forEach(t=>{delete d(t,"data",{})[e]}),this}addClass(e){return this.toggleClass(`${e}`,!0)}removeClass(e){return this.toggleClass(`${e}`,!1)}toggleClass(e,t){const n=e instanceof Object;return u(e,t,(e,t)=>{this.forEach(r=>{r.classList.toggle(e,n?!!t:t)})}),this}hasClass(e){const t=e.split(" ");return this.some(e=>t.every(t=>e.classList.contains(t)))}once(e){e=void 0===e?"once":e;const t=c(this,(t,n)=>{const r=d(t,"once",new Set);return!r.has(e)&&(r.add(e),!0)});return"function"==typeof e&&t.forEach(e),t}get(e){return e=+e,n(this)[e<0?this.length+e:e]}index(e){let t=0;if(void 0===e)return this.first().prevAll().length;if("string"==typeof e)return this.forEach(n=>!(n.matches(e)||t++)),t>=this.length?-1:t;const n=(e instanceof s?e:o(e,this)).toSet();return this.forEach(e=>!(n.has(e)||(t++,0))),t>=this.length?-1:t}first(){return this.eq(0)}last(){return this.eq(-1)}eq(e){const t=new s(1),r=this.get(e);return r?n(t)[0]=r:n(t).pop(),t}next(e){return new s(...this.map((e,t)=>e.nextElementSibling)).filter((t,n)=>t&&(!e||t.matches(e)))}nextUntil(e,t){return f(p(this,"nextElementSibling",t,!0,!1,e)).sort()}nextAll(e){return this.nextUntil(void 0,e)}prev(e){return new s(...this.map(e=>e.previousElementSibling)).filter((t,n)=>t&&(!e||t.matches(e)))}prevUntil(e,t){return f(p(this,"previousElementSibling",t,!0,!1,e,!0)).sort().reverse()}prevAll(e){return this.prevUntil(void 0,e)}siblings(e){return o([p(this,"nextElementSibling",e,!0),p(this,"previousElementSibling",e,!0,!1,void 0,!0)],this)}children(e){return f(p(this.map(e=>e.firstElementChild),"nextElementSibling",e,!0,!0))}iframeInner(){const e=this.get(0);return e instanceof HTMLIFrameElement?new s(e.contentDocument.body):new s}}function i(e){if(e.isEqEvent)return e;let t=!1,n=!1,{currentTarget:r}=e;const s=e.stopImmediatePropagation,i=e.stopPropagation,o={isEqEvent:{value:!0},stoppedPropagation:{get:()=>n},stopppedImmediatePropagation:{get:()=>t},stopPropagation:{value:(...t)=>(n=!0,i.call(e))},stopImmediatePropagation:{value:(...r)=>(n=!0,t=!0,s.call(e))},currentTarget:{get:()=>r,set:e=>r=e}};for(const t in e)if(!o[t])if("function"==typeof e[t]){const n=e[t];o[t]={get:()=>(...t)=>n.call(e,...t)}}else"isTrusted"!==t&&(o[t]={value:e[t]});return Object.defineProperties(e,o)}function o(e,t){if(!e)return new s;if(!t&&(e instanceof NodeList||e instanceof HTMLCollection))return f(e);if(!t)return new s;const r=t instanceof s?ownerDoc(t):t;if(!r)return new s;const i=e instanceof Array?e:[e],o=t instanceof s?t:new s(r.documentElement),l=new Set;let p=!0,u=i.length>1;if(1===i.length&&1===o.length&&i[0]===n(o)[0]||o===e)return o;for(const e of i)if(e instanceof Element)l.add(e);else if("string"==typeof e){const t=e;o.forEach(e=>{e.querySelectorAll(`:scope ${t}`).forEach(e=>l.add(e))}),1===i.length&&(p=!1,u=!1)}else if(isIterable(e))for(const t of e)t instanceof Element&&l.add(t);let d=f(l);return p&&(d=c(d,(e,t)=>o.some(t=>t!==e&&a(t,e)))),u&&(d=d.sort()),d}function a(e,t){return!!t&&(e.contains(t)||a(e,t.ownerDocument?.defaultView?.frameElement))}function c(e,t){if(!t)return new s(...n(e).filter(e=>e instanceof Element));if("function"==typeof t)return new s(...n(e).filter(t));if("string"==typeof t)return c(e,e=>e.matches(t));const r=(t instanceof s?t:o(t,this)).toSet();return c(e,e=>r.has(e))}function l(e,t,r){return u(t,r,(t,n)=>{e.forEach(e=>{e[t]=n})})?e:n(e)[0]?n(e)[0][t]:null}function p(e,t,r,i,o,a,c){const l=new Set,p=new Set,u="string"==typeof r?r:void 0,f=(e,t)=>e instanceof Element&&(!t||("string"==typeof t?e.matches(t):t instanceof Array?t.includes(e):e===t));let d=[];e instanceof s?d=n(e):e instanceof Array&&(d=e);for(let e=c?d.length-1:0;c?e>=0:e<d.length;c?e--:e++){const n=d[e];if(!(n&&n instanceof Element))continue;if(p.has(n))continue;p.add(n);let r=n[t];if(o&&(r=n),!(!r||a&&f(r,a)))do{f(r,u)&&l.add(r),p.add(r)}while(i&&r&&(r=r[t])&&!p.has(r)&&(!a||!f(r,a)))}return l}function u(e,t,n){let r={},s=!1;"string"==typeof e&&void 0!==t?(s=!0,e.split(" ").forEach(e=>r[e]=t)):e&&"object"==typeof e&&(s=!0,r=e);for(const e in r)n(e,r[e]);return s}function f(e){if("object"!=typeof e||!e)return new s;if(e instanceof s)return e;let t=0;if(e instanceof Array)t=e.length;else{if(!(e instanceof Set))return new s(...[...e].filter(e=>e instanceof Element));t=e.size}const r=new s(t),i=n(r);let o=0;for(const t of e)i[o++]=t;return r}function d(e,t,n){if(!elementStorage.has(e)){if(void 0===n)return;elementStorage.set(e,new Map)}const r=elementStorage.get(e);return void 0===n||r.has(t)||r.set(t,n),r.get(t)}return{wrap:o,ElementCollection:s,getStore:d,deleteStore:function(e,t){return elementStorage.get(e)?.delete(t)},defaultDelegateObject:r}}function registerTemplates(e,t,n){const r=getRootScope(e,n);if(!r)return;const s=e=>{e.querySelectorAll("template[id]:not([s-static] template, [s-detached] template)").forEach(e=>{e.id?r.$templates[e.id]?createError("Duplicate template definition",e):r.$templates[e.id]=e:s(e.content)})};s(t)}function htmlDirective(e){return{name:"html",callback:(t,n)=>e.watch(t.att,watchRun(e,t.att,n,t.js),(n,r)=>{(n instanceof Element||"string"==typeof n||n instanceof e.ElementCollection)&&e.wrapElem(t.element).html(n)},()=>{e.wrapElem(t.element).html("")})}}function showDirective(e){return{name:"show",callback:(t,n)=>e.watch(t.att,watchRun(e,t.att,n,t.js),(e,n)=>{t.element.classList.toggle("s-hide",!e)},()=>{t.element.classList.toggle("s-hide",!1)})}}function modelDirective(e){return{name:"model",callback:(t,n)=>{const r=t.element,s=r instanceof HTMLElement&&("true"===r.getAttribute("contenteditable")||""===r.getAttribute("contenteditable")),i=e.wrapElem(r);let o=s?i.html():i.val();r.hasAttribute("name")||r.setAttribute("name",t.js.trim());let a=!1;const c=()=>{o=s?i.html():i.val();try{e.exec(getRootElement(e,n),`${t.js.trim()} = ($$value === undefined && !reset) ? ${t.js.trim()} : $$value`,pushScope(e,n,r,t.subs,{$$value:o,reset:a})).run(),a=!1}catch(e){createError(e?.message,t.att)}},l=[];if(l.push(t.delegate.on(r,"input",c)),r.form){const t=e.wrap(r.form,r.ownerDocument);l.push(t.delegate().on(t.get(0),"reset",()=>a=!!setTimeout(c)))}return l.push(e.watch(t.att,watchRun(e,t.att,n,t.js.trim()),(e,t)=>{e!==o&&(s?i.html(`${e}`):i.val(e))},()=>{s&&i.html("")})),l}}}function refDirective(e){return{name:"ref",callback:(t,n)=>{if(!t.js.match(regVarName))throw createError(`Invalid ref name: ${t.js}`,t.element);const r=getScope(e,t.element,[],{name:t.js.trim()});return e.exec(document,"$refs[name] = $wrap([...($refs[name] || []), $el])",[...n,r]).run(),[()=>{e.exec(document,"$refs[name] = $refs[name].not($el)",[...n,r]).run()}]}}}function textDirective(e){return{name:"text",callback:(t,n)=>e.watch(t.att,watchRun(e,t.att,n,t.js),(n,r)=>{e.wrapElem(t.element).text(`${n}`)},()=>{e.wrapElem(t.element).text("")})}}function componentDirective(e){const t=document.createElement("div");t.innerHTML='<span $$templates="$templates"><span>';const n=t.querySelector("span").attributes.item(0);return{name:"component",callback:(t,r)=>{const s=getRootScope(e,r)?.$templates[t.att.nodeValue];if(!(s instanceof HTMLTemplateElement))return createError("Template not found",t.att),[];const i=t.element,o=e.wrapElem(i),a=[],c=o.delegate(),l=i.hasAttribute("s-static");i.removeAttribute("s-static");const p=s.content.cloneNode(!0),u=p.querySelector("[slot]");for(const e of s.attributes){const t=e.nodeName.toLowerCase();"id"!==t&&(i.hasAttribute(t)||i.setAttributeNode(e.cloneNode(!0)))}i.setAttributeNode(n.cloneNode(!0)),u&&(u.innerHTML="",i.hasAttribute("s-detached")&&u.setAttribute("s-detached",i.getAttribute("s-detached")),i.hasAttribute("s-html")&&u.setAttribute("s-html",i.getAttribute("s-html")),i.hasAttribute("s-text")&&u.setAttribute("s-text",i.getAttribute("s-text"))),i.removeAttribute("s-html"),i.removeAttribute("s-text");const f=document.createElement("template"),d=i instanceof HTMLIFrameElement;return d?(u&&(f.innerHTML=i.getAttribute("skope-iframe-content")),i.removeAttribute("skope-iframe-content")):(f.content.append(...i.childNodes),i.appendChild(p)),i.removeAttribute("s-component"),i.setAttribute("s-detached",""),e.processHTML(e,i,a,c).run(pushScope(e,r,i,a)),d&&o.html(p),i.removeAttribute("s-detached"),i.setAttribute("s-component",t.att.nodeValue),i.setAttribute("component-processed",""),i.removeAttribute("$$templates"),u&&(e.getStore(u,"scopes",r),d?(l&&u.setAttribute("s-static",""),e.preprocessHTML(e,u,f.content),u.appendChild(f.content),e.processHTML(e,u,a,t.delegate).run(r)):(u.appendChild(f.content),setTimeout(()=>{l&&u.setAttribute("s-static",""),e.processHTML(e,u,a,t.delegate).run(r)}))),a}}}function transitionDirective(e){return{name:"transition",callback:(t,n)=>{const r=e.wrapElem(t.element);let s;return r.addClass("s-transition"),r.addClass("s-transition-idle"),e.watch(t.att,watchRun(e,t.att,n,t.js),(e,t)=>{void 0!==e&&s===e||(r.addClass("s-transition-idle"),r.removeClass("s-transition-active"),r.removeClass("s-transition-done"),r.removeClass("s-transition-error")),e instanceof Promise&&(s=e,r.removeClass("s-transition-idle"),r.addClass("s-transition-active"),e.then(()=>{s===e&&(r.removeClass("s-transition-active"),r.addClass("s-transition-done"))},()=>{s===e&&(r.removeClass("s-transition-active"),r.addClass("s-transition-error"))}))})}}}function directives(e){const t={};for(const n of[refDirective,htmlDirective,showDirective,textDirective,modelDirective,componentDirective,transitionDirective]){const r=n(e);t[r.name]=r}return t}function createElementScopeClass(e,t,n){return class{constructor(e){this.$el=t(e,e.ownerDocument)}$dispatch(e,t,n=!0,r=!0){this.$el.trigger(e,t,n,r)}$watch(t,r){const s=e.watch(this.$el.get(0),t,r);return n(this.$el.get(0),"currentSubs",[]).push(s),{unsubscribe:()=>unsubNested(s)}}$delay(e){return new Promise(t=>setTimeout(t,e))}}}function createRootScopeClass(e,t,n){return class extends n{constructor(){super(...arguments),this.$templates={},this.$refs={}}$wrap(e){return t(e,this.$el)}}}function initialize(e){const t=createClass(()=>e.sanitizer),{wrap:n,ElementCollection:r,getStore:s,deleteStore:i,defaultDelegateObject:o}=t;e.defaultDelegateObject=o,e.getStore=s,e.deleteStore=i,e.wrap=n;const a=createElementScopeClass(e,n,s),c=createRootScopeClass(e,n,a);r.prototype.html=function(t){if(void 0===t)return this.get(0)?.innerHTML;if(null===t||!(t instanceof DocumentFragment||t instanceof Element||"string"==typeof t||t instanceof r))return this;let n,i,a=this.get(0);if(!a)return this;i=t instanceof r?t.detach():t;let c=e.getStore(a,"currentSubs",[]),l=getScopes(e,a,c);if(a instanceof HTMLIFrameElement){const t=a;unsubNested(e.getStore(a.contentDocument.body,"currentSubs")),a=document.createElement("body"),t.matches("[s-static], [s-static] *")&&a.setAttribute("s-static","");const n=c;c=e.getStore(a,"currentSubs",[]),n.push(c),e.getStore(a,"currentSubs",c),e.getStore(a,"scopes",l);const r=document.createElement("style");r.innerHTML="body { padding: 0; margin: 0; }",t.contentDocument.head.appendChild(r),t.contentDocument.body.replaceWith(a);const s=t=>{if(!t||!t.parentElement||t.matches("[skope]")||t.hasAttribute("s-detached"))return[];const n=s(t.parentElement);return n.push(...e.wrapElem(t.parentElement).children("style").map(e=>e.innerHTML)),n};s(t).forEach(e=>{const n=document.createElement("style");n.innerHTML=e,t.contentDocument.body.appendChild(n)})}else if(!(a instanceof HTMLTemplateElement)){for(const e of[...a.children])unsubNested(s(e,"currentSubs"));a.innerHTML=""}if(a instanceof HTMLTemplateElement?(l=getScopes(e,a,c,{}),n=a.content):(l=getScopes(e,a,c,{}),n=e.preprocessHTML(e,a,i),registerTemplates(e,n,l)),a.appendChild(n),!a.matches("[s-static], [s-static] *")){e.processHTML(e,a,c,o,!0).run(l)}return this},r.prototype.text=function(t){if(void 0!==t){const n=`${t}`;return this.forEach(t=>{unsubNested(e.getStore(t,"childSubs")),t.textContent=n}),this}return this.get(0)?.textContent.trim()},r.prototype.detach=function(){const t=document.createElement("template");for(const n of this)unsubNested(e.getStore(n,"currentSubs")),t.appendChild(n);return t.content},e.RootScope=c,e.ElementScope=a,e.prototypeWhitelist.set(FileList,new Set),e.prototypeWhitelist.set(File,new Set),e.prototypeWhitelist.set(c,new Set),e.prototypeWhitelist.set(r,new Set),e.prototypeWhitelist.set(a,new Set),e.ElementCollection=r;const l=directives(e);for(const t in l)e.defineDirective(l[t])}class Skope{constructor(e){this.components={},this.directives={},this.globals=Sandbox.SAFE_GLOBALS,this.prototypeWhitelist=Sandbox.SAFE_PROTOTYPES,this.sandboxCache=new WeakMap,this.styleIds=0,this.calls=[],this.varSubsStore=new WeakMap,this.sanitizer=e?.sanitizer||new HTMLSanitizer,delete this.globals.Function,delete this.globals.eval,e?.allowRegExp||delete this.globals.RegExp,initialize(this),this.sandbox=new Sandbox({globals:this.globals,prototypeWhitelist:this.prototypeWhitelist,executionQuota:e?.executionQuote||100000n})}call(e){this.calls.push(e),this.callTimer||(this.callTimer=setTimeout(()=>{this.callTimer=null;const e=[...this.calls];this.calls.length=0;for(const t of e)try{t()}catch(e){console.error(e)}}))}defineComponent(e,t){this.components[e]=t;const n=Object.getPrototypeOf(t);n===Object.getPrototypeOf({})||this.sandbox.context.prototypeWhitelist.has(n)||this.sandbox.context.prototypeWhitelist.set(n,new Set)}wrapElem(e){return this.wrap(e,e.ownerDocument)}watch(e,t,n,r){return watch(this,e,t,n,r)}exec(e,t,n){e=e||document;const r=this.sandboxCache.get(e)||{};this.sandboxCache.set(e,r);const s=`sync:${t}`;return r[s]=r[s]||this.sandbox.compile(t),r[s](...n)}execAsync(e,t,n){e=e||document;const r=this.sandboxCache.get(e)||{};this.sandboxCache.set(e,r);const s=`async:${t}`;return r[s]=r[s]||this.sandbox.compileAsync(t),r[s](...n)}defineDirective(e){this.directives[e.name]=e.callback}init(e,t,n=!1){const r=[];if(!n){const t=this.sanitizer.observeAttribute(e||document.documentElement,"s-static",()=>{},!0,!0);r.push(t.cancel)}const s=this.sanitizer.observeAttribute(e||document.documentElement,"skope",e=>{const n=t||e.getAttribute("skope"),s=getScope(this,e,r,this.components[n]||{},!0);registerTemplates(this,e,[s]);const i=this.processHTML(this,e,r,this.defaultDelegateObject);this.sanitizer.setAttributeForced(e,"skope-processed",""),i.run([s])},!1);return r.push(s.cancel),{cancel(){unsubNested(r)}}}preprocessHTML(e,t,n){let r;if("string"==typeof n){const e=document.createElement("template");e.innerHTML=n,r=e.content}else r=n;if(t.matches("[s-static], [s-static] *"))e.sanitizer.sanitizeHTML(r,!0);else{for(const t of r.querySelectorAll("[s-static]:not([s-static] [s-static])"))for(const n of t.children)e.sanitizer.sanitizeHTML(n,!0);e.sanitizer.sanitizeHTML(r)}return r}processHTML(e,t,n,r,s=!1){const i=walkerInstance();return walkTree(e,t,n,i.ready,r,s),{elem:t,run:i.run}}}return Skope}();
